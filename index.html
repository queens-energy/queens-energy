
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <link rel="icon" href="melete-logo.png" type="image/png">
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #997f5b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">

                    <img src="melete-logo.png" alt="Melete" style="display:block; margin:0 auto 30px; max-width:150px;">

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Melete Energy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"edca67cdc3fe280ed4b336c5dafcda05ee1cda7b478b0f35a58d9e8259c4f56e39eeda54c37fdb96f28eecdbd86b7886bb20d6d196b47c5a8f6673a556e346821a210dc9e7a49d4f6c271993948a53915ab4dbd56017de6d4b54ea26539a35d27743d2208d8406a20226440a72fb6653cc2e571bd77e4ba1947f853cca1923593cd8d839f1ede473f852b7647a8e9992804ee13701eb219316375fa461bbc90177eab0ec7da3355446294b24b43f79203c45584ed03aee8744405cbfe5ae0de4944a31608e0d74650e3713af2b4c2fb187a5329d940f143cfdab38c52b8e8f13cba7351399386700366bb346acdc63f2d020e03c2419a22493b7885ca1d9237920785dc6dd22d81e9fd5d88e776386930382fe23810963adbc1a9ccf1f73b85cd72390d8c689a036a3e76933572a24fd5238329e8567bb09f46945880136aa296b78977771ef7e790437f0eed505fb919fb420e986d8b433e12191005fe158792c36459a69027c94baaabfef26fbb73cdbefe284f3cd62dba00365dbea5712952086a9308413a6e2717a2836f3508f598a6b40c2722cea035d11102170ac8c85a32abf43a5a3a2f3cd1272b73aa4cc31168b85ee50e827571cb090e54f543fb165f4ab13d940319505b9b7f8d05769fb15300a6090ca44b5b6990db60f9e7464a335f4de3dfbcef2978bdeea22de759e4a61af691aa5a07b820f7ef899b035ca20acd5ed089de4da8d5bdbbe2c9c68d5243faa5277471febe29d8c7f48041f51c9d17a3be33d55083a8336eff1b17e7e4a7d0c33439a8aefae53783828c5ddfafe735f49516d862732c3725c246ccf7c7a9f9e7748e1289b635fedc08e0332db20b8521ba1f6083f5884c76864e8c5047df31c9e2ddb3c44f5f6c864ea145a53ce42f3eedcc7f66703223c584ef1fad611e2cca5dd8f3ca0ded42ab028cdbb034fefb01007fe56655c4c1f41bbcf00a8ee7ad2f463515717b33d94b75af3874ef0c70620e0fe0a0fd2deecc026bf63249bdc810527d034870fbfb745e945e95ba85e816d181fb01465c630ac23b668c113058eaf0db613ef5ba60ddf4aef3736d7615ad8e0ccba718daa63c7991d16db187ac7ce609a324fe0ac8993f39f493b8cef74638d22a74a3a36fe25709655f2a5a7247cd99dfe0120b8e0794d589df0ea3ded8f6d42185e50486af72d8cc6fb388b6ff6305e7e3723959fdd4cfae2b76757e8c5a9b8cda7565e67c1bbbcb11d0e8c8e6bd84e4402f5f63acbb8284bd8e5e080fe69e26a9ed99fb0f4749635cc0e92de14ac2836e255f1c3e91789504887416d65694c1523ff6cd511dd062ee816f52118cc3f79047dfb82d83f4474a1977669b94ccbb3c31f89c11c9daede6f64ebb5abfeae25ba1bcdd107b34f008ea1cb165b168663ee5672e9429e4b7c08fa6c404ae417183056a5b2566e164901bf50d45417126db9a157d2bce910aa8a36d4a647d2fd3d95528fcfa2e2f5c192580f2aee66876669d5ce2f77767da10a8a22a4869aaa1fc31f35aa9207bf0514048648119d21058e1bdfd42a0840a700d55b5318a54ace29346b47d52e6198a3db3cde70bfea180c945a398870140004a98daa9a9234ca61716757e3a539eb365761938e13e2bfe2cc3f72978d011c95618ec81e30565e0c29ec86a72cd2c8067aeae4d60c25852303dc9152087a9e1524d9535328cd0a3d348be6b7bab3e1dcfef0fa90a8dfb763274933b7daadc08fb9d16540a1566ff947f610a52dadbd813f05fe7a86a2399b8a057132840f7fb765ec0149a479ff44b1d9529da8b0ad2688c5fb94bdb92668e1c99919548d60a9200f4b67c5c073b1272a3c01d37aba0b6616b4a0a45e5f3776478b71f1d1aab2613533ed0ab7e43aed25c9de083686200825f8a2a21346f7a9a4138c179acca415cd916706f893e748696d05f7269989323065563808cac03177f0b4301d81afb0a6155e5fc55371007f59cfcd5f147d77b2cda8c4cc3bea69349902405ecf268d3c4967c22fdf438a5b5c939f3001f1a8d4f0de8287ff6e9bfec3151e1b71510dfc4be144fe1fb958970961b1427b4fbaefbe612ff55895dc2854074a307be782ee4d889f1f8a409d5d288d13f81e00f6243b136a93717735f218aa11b4b5ccb9e7491233a8da240b7ba52aba67477a8497086e81f1d2e7cb02cde551506a5a1a267f7a4afe35744247afe33fa4b7a3a335b85b08022da1882166d8de6e0719b9241dfff4b4ce209b93d018b010b5b5bf1ad901e97105189b1d6b6751974113cf9c667fa5151077cae2d3f9300b6505f006eddfa82d8834af24248e02b2960c0d4f3ea758b31c24c5228e0986bfa9ad4baee889a608c764327dde73c71445cfd33342d4283898fce89fa0a4f127b2512a1f7f1c7690e5f30098cb5b0612d398d92df4d61f80cfcf5f5a401ebb37497ca6a147eed8c676827fa0349fb770c157fdf6c52d238d6e3a6d1dc864aed34f59073a51e7ccb25dde42366c32cd935097b626365426225b91f2fb355d491e6e7792987dbcc30381636d290be4bac8b356ea1e87fe873382dc6d772d2108ea44ff8835d1f157e957896681c72a369b68ac05c5c2744b8662af25e14971f055ceb519404f2c5e9ff21a114dfceb6b448c7340241b62b04c61cc61003b43f14a9fb261df1cb2be407d87cb059ee6d768155f6e2045c8faac8f3db9f07f81a443a187f66d76b9d595346da65512a17313be1852537228052cfce0d01530a92eda9413e280e74f1dc9bbab5d7a6ec3e73fc0bb14e664f651a28dfc8b228b3f45093903589b950affff87397010134ce01baff4d60a1df5a4caa1be07f59d53cba67127eb7a6138d793bfdc06f40ce459afaed4c3defdf768485d0c61e088ce0bb7933b4499f7deece1ba7f715ac690e76e06851eb720b3f2f8c032da2190d3cdb3c12355841a26a1a61e0bcbd3097033b0875f4f652b353abc64caf45d1d328950c07ac0b9996e4f7d889e077594f45e40773b6a7fd77d89fae3d93cf90f3f6b31352b234926bae73528e39b263b73ad1be9efc88ef14308116a777f4f67613feaf52969abb8a3254aba4f0db663b5148c4331fe5546e8f5288427bf5312b45f18d0f76df69a910cd3b9f0e47ff471af5e5f84768ac68ff17446ae907077efe00dd34fba32644d59f2a38ab064e3cc742881bb06de25a78c898a080cdb3acf4ba79b0265a425033f5fd12233ac8e0b32165ab1f02be4002c75cfd5a963be0ad7e4ef8d0e142a0d33c603baadc7f90b1e8feabd2a624fb8280d4e1c1c63073f341c571ec27201967d9b923750ea353859627b156e331e70d6a845c6ac446cbf3d98a2be9ae10a2828740104fe492bf527e7b8c47c628a00456c54aca31cbcfbeee08ce7574659535c9ef1529f8af62be921b365f5bb28c06e55680259b9dc4b9c8888cff4756b67eb4a84d4082057c34371469e145d48efc3c732ff553e48bb54f17780f7be693b882b107b6969a94d11ea85419d78bcb9ffdfb63e15956962efe1bf08324499b444a7d1edee64b6494e2fdbcfc484956396e6710398a512ac2c0543017184b0ef878ae67a78ddc2c82f21d32530dd6d6b72b023d7cb4c834e79a537494cedfa51cc5654701bcd7fc62c675ba9fd87d9b382690dca6e7fb8d8062267b43252de13ef6283871371ae590b18f12f6d9c32f25d32ecca129ba64d2f0e566433db085c0d325ac5282ebed66609b37c1e0e90148df433d2f60ad28cdce1af0c9fe875ee9e29c59b205f48eda3c35a53c06e9a1fe6edd92033bcc214922619647e341722544ca3b66b464f86eb67fce3af0ac0c7b3257a0c761929c7803f674184a03140bda238a07e70df6ef5389c8a9edc8d4c00c6c70568371d555aab0713e1f2dd2489fa278085ab4d6e4e63556d45dcdebfb232b1d4f82b6314b61ca469e1d289d6f262dbcdc96abba69f2820d0365d49843ee38afab56ffef629523338a84316fa414722772a5cae2388db367ecf576c342a4462af28ef4575813c96046e5e85af9cc8fa2679883d27ab3749a5b8c70f09b7df028284416e2488526df680b08aa37c9c0e4d4a4d2266403b788b9eef43202dbd42c12cf5f3904ad0ed1a6bcf9821f1a57f51f89531ccff3a5bd6c71ab4ff5342d9ea0b5d2606ce133ad5c551c9c6531be169b3e2d882db8eec55870f1967aa301004e17f6d6ae3b0b0aa376ee3538cdd8379b7591783d38a1221fdae01a56d97eb0e277187ee82e13c7431bf3e23de7508216eda9395aa074aab55cc50ef5bfdd1f9bd11d61ec8f3ac77cec17e42bc9b5cd04b61bc164ccd700efe7f9725b57653dbce147d7a7a7414446bc25bdf21cba0c09958bdd1666958726f2311b4ebda12eeb46e85638455cc7f4f73cfd7ae74eef594877f80b44753fc4f3e5f85525c4a4f4530173085731ee95ef745c85438f5bb22b138c37ae8cced66b1b9d38110964404e5b9d9fe17cd34ad6348e04173a24ec598f899496626d6daab2521148f468a94adf78504ce5d45f21ec9ae4c447b0ec344d6c0b95a09e6ce9a82e34f9608fc7a41a832fe260285ff287d161ebf8bb03583059f0867c66ff5a5f5ee2e93e086a32d846a528c2052d4440a0aab66b6855da08df887c5c370797d5f10b76ce205098570dd8e52972d55d5fe09f520935a6a8edd9094409c8cb33238279d880072672c60382f313a3ea0c1c86abdbf103b188edd55d8edaf8826cf0b4d6eee683805a4bbf153f8165f7e0ede85def3e27def95da62bd913c7d04d4cc3952892e7f6ba8ff8e9c2daa7a70c5b1eef2664da01f1bb8f8f2f26593d007bdffb26e55b05dbc22831b8fcb528fef296125e6a81b1e7e4d9e9cfdaeea7c7989deb47cace36b1cae7d88fb81a2f0be558cd9903dff427f3098e8f84eff373777b803d18482e9e1aeb5e285fbe7a952c4406ae378607ef95a53cf14a64a61f695f01772ae851d0fa165f2e1aacb9bded14e3e216347ae10341a86ac774a1c206982d3bd4d8cb41edf3bf635e0c5de14d1cf2ad5041518a00a319fe96fd33f32a9ebe462ac7a8c9c86460fee624fad3b693aa70e94b8515fb654459be59ca3abb995da3dfc23c8e7ec1ac4c48485f614917c6d06a9c44e1bc0f4bdfa166c8acfc7641b08d4861ac1b2e9d6af581b3fc694bf4fb1b20b9b8edd4cf58ddc56c7dd7d719d9519fa60b92dd1de965fc277606d0dcebc927e8cbb1e0e6674a129219b96743895cf0c0bc2ed83fd08d2b33a5199502e2501e7f491a317d88d40f579470bea21640c5a3235f26270adcb33bc4c4adc61f865aa1320be377bf2efb2cf4b43851f8cadf6340ad922e148d106dccc5aeda4cee4a25e9547c9e1ad2c355c80eb3b2abe7a6e5b8fcbdc95d880bc9131a6ca2ae5b03f47b937560e79e6b31b08e1f701e01f26f39695ef173735b90ee01985ccc0c82d2de35fb50cafb589d6c48c812a694f0ce3c3e856de6596556a6adfcc7ab13d1584d24c9f63299d5ce96eb1d3648aa02aaf87b64b6667e8cf3eac1674deb0dce2489150b684d6a27a3ec981645fa0ff5d44f9efab3ede7574b690d0132456a65e33d44470ca7672a60239f738359228f3b3b03e016a06618733875d36e0484c5aea2a1bad739af53b5dfcc03561ceec7bd6551882ed3a6997e6767c3393d5e19762a51775b76cdf19a2fab62ebff3f0ae923bcba2f8bb327ea4a1df9f53e5b8c23454f6742ecb738972249da6e058873b28fb8aa65be0f9587b7f409134ed0283d227667881a25a8f0a82c4bab4f0713ab99d66b25761a8d7b2065a8375b8161c4068f9fdeb76591260b195d06b8ec8471e6a291c958c5eed164bef21aaa37617862d65749611ef97870fe895868221e24b0c0436a17df3e82c83267f8860be68399f910bba7afd8b11821f5ae9e60d280f7106978b907e8c86e751d91dfbf13ee43c7b9336c490108b70c0e430cfaccedd3ce0c9b8026dffef2cc51f70d6328e79ab3399610a15dea46141e0920a37541e7310e0977aa2d8ad26d0067577e56dde9c581b61b4c2118148f719eda8e7658d8b983cb1fc2490edbe8ba817e2d3d7d5c04ec39c82342a7133a05c78a0ac6b864c89519d3096d890f8d94dc2bd33f52b8853aebe83bd6bb706e457e2638cf118790caa1ad9fc8896c7369a27825ebd3be772775404e8e3d5c331164de6c567b3b3a8c4d0a22f6d3b2afdfb9064aff741c6d4ebeda8af1836d0a9c2126f8c8902318fa6673ebe85b91a5a5365179a978fd7d234c1ed8943fa087b5efb9abbb3793de5dd870f059954c9ff1afd18107ceaaeb1bd780b25219f266dcea4ff37a94d3fb770e34d8836ac6938fbbcb58beca9d85b730d14aae51b4b34f8e08e39e5343400ab73e3ecdd43502fc41d67c9584f333772e4c3139612ea5ede8f65ead9ebfb71e7beafb20e5c2c3aa80a58d18f7d56b35e74dd0c46613bdee97af555d2ee7ae39ca8da8d6bb64396dce3333bf06707453859d6959c456ad6d683155a7c3686b785e8fe960d358ec986389d900fc29ed33bed1f1ddc563763712da1fa81b4cd9ae0ef65f591b7c7a750b78278a200db27a014317f3eab6d4238b758bef1a905dd6b5ef9e149cbf227eb5da7240a5beda2f354ff65b59112d1a0b30a284958404860b0162406df9fbdb38afea4b47ad1b76aba16e6606384923c82d870db4b2aee55792ae533f5932eb7ac86893186fb106bb4b2bbd740ace3d1aac59312d1b6059d20c33760c7410517d21e5ee5cb89bb1feda5036dde667eb57a20c7b21c3fd499180aaff3a3401f1802d70a4f56a0082129bde8600e63e286c8c41f4807e5c792a1d4a3bc2d87be3492c4a620855db0bf8e61ec3228562756ae2c89cf5a57ae7c91d44f8f44e5bbff7a17b73f1d83de584f260f584c7d0dc8a419cb904df22b5aab196b3b3598ec2de62093e93f79da48bf6acc8a58af68adb080a854e42bc07b897ea4526b6ec12f95b9bc42fb0454c1bf860dc62f036523c8b540766d69d5cfe9fb5aa001d47627075a9854cd86af7fefa9d29bf8bd05aa65073f1e0b49a7cf917cfa67167519ab54b100130c272b6378a96104ae0c20911fec596e75ab573c25bfd6705745c97f64b67eb7551e904196ea7dd5690d6793896b52a69661200aea8c4a3698ae073cb374a85f1a832c0457a482e1f21fd8cbfed3587a9344ef4954eb3f9942115440f3d6f41841d880bbcb2d5b291294ba34aaced4f6fb03afaaf6b73a2911a133b3fcb6fda5b405fd8e01be79f44222dc3b874a1abae61d11c251263cfc28a59cdf7136f5f56b65cee951f5b14785f39375b6796551bd3055f0988c082a7be9f1b960fbaa1e3cb92c6b1a410c5731a1ffb2e982ea60b6acffaa3b11caa24d14649fa17d159a3285415b1a8eb5fbe4b5c7ca1f1f4f9234751bdbf2817f9224ea249abc6c7ff38a22c1cf1473dae8b200dec24c3d662be9d6d69ed0fe6e519f30096aadac657b2c9551924d6c086da801006ff5ae7b2daaff63daaa4e36711a436d27e7243f01cbc9683eded56c95e11c2a7a772e942378a800400ab922363ee9eb985770a1dec2291fcd220994586a97cfba78026775ecc0c77e214ed52da3f3b4e03100a514d864b0193fc05d17381f4d059e6b5d017fa9c959be4d87ccedb98a1eb1e5876361446e733191a18173e9e6cfb7e9b29cac8af44d11dfad59815ea9d020cf4923acf52c1e6dd4947dd55940e1eb4e5562abc575c29826bcd4ef746a6c5e811305adad7bffe4c21dd9a25448cb22f0c0c64dfcec4d3cb750347a4762ee1fd931265f7d24a8b6591c006bf1dfa7605e84633889cff0e4b60357f8c1427b6ca8ab7d1fb53baf224ba6458be3a4df9fc0d613a766fdfd84e0f50206949e5ca98f0db5ae4c8b17419a2eb8c82511327965fd0a1bd96afaab57593a1bc6dc70c6bae6205cdc24a8ca643bbbf54569afe1743ed33e8f73a23a60f9499e195c0da6a98c8a21e342e1a1767f898687a0702e7b2d4d452fba0d860c4a027ebcc7ca11b2cf12928ebf07cdaf4352550bd8eb0257524763e29ef4641699be1b752ac12b0959cb6fbff160986c2c4a52a2a02860e902d74017ca56b55e36276f9741ac7e433e7168928afb94ebb0413bc1c58ac6bb13642ca8453058e587351e503e588f946681bd0212838f4c6c4d82b5fab6739615d3736b6d66e80b367dd865649bf9829921db6b4bedb7004a6de7c8eeb413579b583121d639ed35f50461d860900281c60cb45e2aabdc1149c5aef3e51ab73b88335cc1bfbd980eb0f6cb9dd0463951b75e6e5894671922e4745e94c4a321ad4762d62192a8e9eee2686ea31addefd124ae7a35a0b4b4783f0316565367439e6c96c38dda5d3d92fab48abc6f990f954a2d0f9b9b915456fde07b2e902d60205cc9b1d7e14daabd462678f69b51c4310a109ccb307a9e7f543150e01c817f6c3fe5abacc5738dc831e201e669ed96519a81a05ba58f65c4015bb7954921235a14bdf49b70c02133e0236068cf7d9f6ef901e1356b2071c5d90107725f24ca4168eb2b0b863954012f828e3cf4ea758166222b19f8e87e7001a925df7d1900d95c123e18846f7422cfaf88ff8390ead8e3705676bb1fa0ebbd1ab585e4513d4cc73a2450b3c585d33a9cc9fd0c486dc6d3baa69ac2aaca80eea7b3fdce5f9a3ed85b88ad7a3c4455242081f2df4763f14635ea03c32cef49da257f61e7f89aa1d3abb333ceba31bcb8a7a548410fc15595cd27acd07772aa63a2710000016374b3f268100a6cc08349a3b1ff5f37ff056df327122c6d5213cf637be0ab0ace26c5f1c2917b24152c4dbfd9ae2c49e4838ec7fcb532a7128ad923affdd9c8fb7daca48c4490e732a394a133efa6d06593bf0a615a9ae3360870ae86ca6fbed4878ee58ce0b2187b012ea9a4cb37605d6ee738464a048057bba1f81a009e5c6fbd2eb216424d92d512ab091192f746e008636d7b647e9eff40bf0721dec37d08e362a7b48877cb2684f62fe69faa0013c8db91a2473366b80fd44f9ba53fbfe0d71673279957b45759f19933c902902adf8849df001147dbb22613bab139ad3522f54f3dae0b8642a97f2b5c82d86c51f1054378bf3858105769eb9f4acc98a66553a07b3649519617700512fda7570a7044c2d76f92e74629cf2613f0ed80843afbb7542d6623efb00ed4a9bcd6de19f85a7764f1bd60e0b1b57d82903fdb3e7084d6e377d9862c54a982ea21dfc261f23716a2150e05a49af07d965b11c997ac8926a040789e388115dea24cfcf2425b3d0e539d8d3edb34cadfa9d25f817a9d4f24a171aa969a58c792dc58134c3677c763d6ae86c7636fe206bfcfe3f1be8d4d0d52949f37949ef684128f24e8ec452615a18c5b178d2df774bb402fb5d462c1f52890ec2f6534fba385f118082865037e455084084530db395384d4e7f9ca2aa06c350ec7e0774bd68c2111aeb0b15fa6cc4fe0f08468ad25b0671189124ca49f990cda52dd6ab5622e0c31ed09f5aa3e9b60d4d8ada866ec9cac094f36d67301dd8a0e00ce78c6ad306b3dd81288b732d9388cdc6121ab958ce32cd509bb5dc2ac654446ac3d26728d0ea049f4ead5c6898f004df024ebb6f12efa30d1da46f79c72e23f6d114546d06d35d9376908c878fa2cf725bf9c7cfb100100b976799a01986d9c0102b6787c3d401923a18f39eed8d595e387714142bab02dedc603d37cc7fe9fb619b435d63197b6597fc9306aeec86a01e19b7cfe7f055fae5f8452d774d89ad669c0cdf24703dccecda4582e219b19640e09e52a629da9996eaa03a8c6148541d623c0ef4877ffef2759140b6ce21b3fa7a43380b4ed22e9bd7925abb069a38870f0cdca6754d56328d1092c27bf9b760db020370a3cc6087ac1ca2cbdc9f221b0b3bd0e2cb824069a6b2982c0c71e31fa5d38d40a8fabec2a9e988279fc35c85dc78b1582ee095d3832c7536048c0772839ce2be57444448eb4d975287e1cc93eeb09f48ef1227ca2a6704769e2fea94bd102465a4529002531888fd6f2b6ad476b7db4e76a745f53ef7680de87465529a6b7799855040621b14be3fa8ac269dd37ca10b54382abac20cb7f8cfd41a6f9c37a791940250694760f044913f2e41247d30ec50fb27e4baa0bdb93af5f1aadf52bc1850dbe5d03581358c88ae84059956b0d8ff9775714126d49ee77c74653c60af5ebaa297f13e82b99da5b825d107ea5236512622807ca2a8e728bb9fa5c313d0b51aa88649921bd13836fab44e72fc22479278ec763f1a3420dd5afee2d57579dbd9ee8f983407b02fdddd92801136cdb7fa1b68fc9166b3a575ca9620693ec4906939d99b5865aca2a5c86d95100764b7e565949c1ba2a46b01520a6295cae0253ee9a604408ae99c690400c2ba38ae717a60a954ab1f68a6664d5668496799ec658d8dcf0c0f2c537f395ef85239e3339dd11000ca27daeca076af13c971d6891a580416f48309c1839fd76b215700853396d2144dd77a42366f5326c4bff61a0611e24c2409ac7cc433e76d42545a8107271f641607c8c36877876324cc1308890402e14b1b38f17a6ffbb10afafcb6d62c7378bc9456f13614968f02746385b2486e139f11d10f96034fa29d35adcba18524ed27e9ef976fdd27a98565694cda8834448ea115583d68a97a8037ded3dfcd2b73cead5adf1f375958825c1acd13a0f942e7290c04e129e25697d2318e364b0a7522d7b8465e7a67e1854e450482bc08ddf3b0234dbc83d826829ef654bfdd8e847451167f1b4531655761f4b3db5aff005da71bce640da6690dfc6902e1ebdf6f321534befe1b749c57f530d4a2c3f2238321b06443b3272e344809a6f789fc60b5b129b6a3b263cb98342e7fc1c4cd6c2b4c28b5c3d94cd90a61d90e9da7e90fe1875f02aadd609a838d627a1737daa706bcc83e0056263180aaa1681dffbfe4052a44c9225bede172ffdf223a2436b7fa43c5e5251cad30b41c2fb24f99fe3c305e089e3c8a5963e8ded017d5257b38d3627cbc93b47f77538eb0bad20e02d04a9ba97893a63a9637cdda7b3cbcca34192f86a9eaa611686e29ff46b06923c220a1986eeeda487d9593368d65e619d21c382c2e9ba848c3cc58dc5f2ee24410920cca6c59b200d896b27a9945d0f43361af9b54dd07665f68ffb6eb9c817b15ee81bacb4b84e530b43ded177ee5ea7dd03bbf4eadb98cb22fb6144c40a6fa6cd55204a6947c7eb3a08bd3f7d00751fbca60009fccaf7ad001bade3a6ed3453e02dd299d7d737853bd06358cb384289a1a9b16a60446b282f37d94ebbe147e3b910556f5662e2120d0102658430021395a6005dda2a52c0ac823c614b50b1861747af0d9d5d508be54c5690fa6a0051c2d262d6f611a94f5a9d716f717a92f92c0af0b3bb5fd323ea75ecd7402e2f86c4d83eeb9c8146f8fdb01eda8d0ed7f6fc8fb94118aba93704c0398764ef27fadfb12c65257a86a4e374b81fa0cdd205c84e9b144862c769d63b852a55ed0b520ab2ae07e16dc69ec6daa256d80b345c76d891d0847a224f60690efabc189f12541a16456f95b47efeb123dec05dd3cb9869b9e1b4d2ca69c0b99021d1871668341435d94d41fa66de108f97fc9922397b9d899304c059ce831d29931ca7d83f7d14d53fc22a59f0c251874200a40556b13d5a4cdb33eecb6d3e0d56bec957b62d65acc1451e4b82f3b2a68683fedc1fb46a27ccbdea08b449f4cfc3711046eb67d2517158668ce16639dfa9a7fd9c5ce80ada95f65749264128bd0fad7ab7f5a672ff0975088d5d882af185a40af1e2543835bf638f9216f5a3ad03913d6f7c80745bc8155fd629e6d8c398eb6d2d51fb82798747f6356713c83887f9d22d591e670a13b13ce975f0d154774a55fabac24b118a4d553604642cc875ad04e5d14a5b127024c29b2b294b00d2eabe71e4530e2e6f741d0a5395c306520de4cb7181d556dabdd8a2381860428d4d5f745f425301dabdaed6bca5b3ad911c407ddcb37165189d7d1c1527bd4edb9dbfc3ca56cd543c742a74d28c3c8f5f68b7b2655b3b07c3199412df9693fdac044fe631159fac0b9fc4657c291b023240ae599f14cf7b31921c885dcfb8df6369800f5114bb3ff1bedaf3192f4845f896a873a21fb60425cf6c4941567683af8bc8f0aac08ceeda163b985e725c9821cfc0db238ee2fa0b1ad5c47a30c725b78c6a439977dc8272d40185f12096c86d7604aaaaef195f089e963ee9e9e9b0851e880394b9df12794316362bb7a6ca8b26c8d6517811e363da5249c3171d1a6938368362b534e75e14336dd5d3617989484fa56597c2990323544cd218eb158c0f5bbd135872bc87e8564e1b2846adb19ae860e7d86a53dbac9e8821c243d8191689370549a7aba079707381ae07c602041934453f38a8a177965e2b4457cf7825d22a2d0ffa0739391cec322e905676caa80e0870ff4cc078caf8d99955a5def1b3556efde18b7d7ec6415568d0e9e3d738b98979e7040c04b2820ae8df0a6fc6a25d38ba99d761301a8ea7434c42","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"dbd0f3fbf43fff071d631761d1931f4b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
