
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <link rel="icon" href="melete-logo.png" type="image/png">
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #997f5b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">

                    <img src="melete-logo.png" alt="Melete" style="display:block; margin:0 auto 30px; max-width:150px;">

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Melete Energy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2dba7867b7590a265dbc965687a678e86947fe181242fac82d7c38124eb7925f0d7ccae8fa9f0cd43f2299b4abc1d63090d34c255fc019f7cf0f1fba1aeeba0383666731325969358f703cb19b7b387e179359e62cff7605d0e9fe956b86c78eaa97da0ba84c0b51a3029f218d1dd7c50b80562d512803e1aebbaf1a5a8219dc21a31d61f22d55ce833099fd1677256f2e448ef7e7ab4817f53e52b36affb0cfdbd7a418dbd4f9a4ef7106419d0d57ab6a35af20a8b0ca95651482b85a62c202d9cecbf967d31cb16e8f9595a02e2181c12a075566516cd074e3abc39ba7633463c76397c834f13fd39a1c9bb974acba72e6b962237611aad3ccbeaa902426d8db53490d3543597f2fc2038dc0cd4291706fe548a8cfdd32c9c060c5d6f368f89a77a760079d484ca397aa5fb1632672dbb66a4bd96876bf6da3c3081d2abd83b07b995db42846a8e78b7dc98e1309403915dc9bd30253c4be1522cf682304183e373c973b0bf60819766c5ef48d7f32a70ec28167c93708e487b8776194ad46d115910f858268549124cacf09bd42cb2a7e82bbdae6328969dc7b2c6e8b24e88076b5a10c08e6de327586942787b9b2355d685781acfd8d93204b4c2d20ccc66cec3a56c036936e568518476a5685be18ae296d7bf46969c7b5aa551805ea3009b551494461c5a06402db5a14c09306d1dc78598611ec890709cfb0fbc92da9fc3bf918db10e6b5621fc3a85092a569a534974e688a5a0b8c6b7387f885312f72c2515acdb03c56cf3c1acd07f38c1808507fcc5e238cf3f2ca4f52a0ffacf2f8dbf71f6273eb450c93b2c4cd1175eed568343d0a0f12d09bd3192c5b7fcd22de08b01669eb4ff66fe7bf94451dcb7e7f444f646e09ed10297aca4e87ee1b98dcbe718019a047185a559847a929a2e81d4dd94c465840088e6676e77b025b2053219345927df4eff8b9386b8d45fefaa449fa65bc166ffa49eb3ceb2e0d8bf96b7cb8dc8e6cae1a9b64226c62d68d46b0cea76efd59aa6ae08ebfa650a0b930ac1bde44bf5c5f08f05df56cf82f7462d611f5d94c4967ac399123246ef851912e13997a2b7f98690e16dd33e6c8d92e351b6386cca4301fb261712f770c04423c2f7307ae223457fb11d28318517d030d929918f427dac50ad6b7258965d34d2d5ada945c410c751550bfa076ef9da78dbc258e2a4c903268ec35bbb3c39986339be7e3cf1a5a7ee09dad126adc68816d4646caefbb9483e5980398c06b062033b824c827d946f6f4b652672b0f8dc7981b82434f7b99ab2f9acaf1cec9a824079fcba4d101abd8f5cf4e965b2b84947a4e4d7d1875382e2158441f41fce264c9574de4464568501f2fc1f04f40bf0f332342bb7dbd9a5b839da9d5a77de6ca5e490859d5124f7aa352c6a0c35e2c157786998900bf65cb92a265c4279fb5d7fc3cfb46ffcedd07a1a916156f6ad7091f9a6b6e0a95d40da74f9dc23ccfb488b1842516f5fa96c6ab1ca7dbcda8728b89b51b1c2c925a408129a7a59c54477f980e1285717b3cb3337185f322a83ae5c88319d660d1865c4c0844e30cd7bc061091c7f91efcf19aff4a7cde232991b3cb4408a6375c447c26f9422c7e0475247500512331f1a6b64d857a6d300789790c9e726fef609f425b7a8f936f04a97ea5a1262368ec64a555abac723adecb7488aff9fff8f690ded4f9127020d146845018e547ffd276ecc7d60abf3d80f864f5a0fcfe9fa128ae8f9c852eab86d824e73de6b1e1913d04dcbb4d0b779d04a581d3a8aeae37150eed44b8bc47c1ec634ece09ae5c89d91ca198db22e135e01cf85906129da6cb8ab8b99f982504f25c74660c553c701f190bff0922fcf22fc927bd520e08439ffeab354165c367306d23f893b6ae1a66516d7c53ab9178b8a95491386b6bcc3d34a23e1ac5e1cff97873b2fcca8983035289c3d5d65901541b81aff8bb81f54fe61f268723e4e730d598dbd0efea03c0e1bc1a7cba4e96fbaf25d46c215a19c5a2b83da21a3b611c2f6c77d9bad2627042864e415b13e03f982c2b8fd91a2f23bbbda20a6dacd19850dbce45b449f21da7d4f1f98fb2324ef86c2d222bc7a9bb69d700f33721782f434b9c57042310661add168d98a545d20a5c45f701ed91e79ce2d794bf32d93e2fa01a6b7862b95008c9c9bcc2e2bce88890464d36f5b2d72d0f26892e3b1c07bca1d80faed830f48ad6347a3b664462f89d7ebd33ec0b822c4a6038f3bc92af8356bc278aeb973de8063bb92aedfc21e32fc3818614612875dc258e823bd66163de23f7a70079f8579a2b95cf7380812f534bb39aaf90d600b3ef3c4baa58bbf3cd65af941f561b4e9b541bd7b45250d0688b113164dbcf387daebb71a082b60864752d930fa5fa96f188199c06c924bbe03c295dbdf156abd6f41054ebc41d6a94f83c2b1d32055aee934be3d236170b7847d1713cdc229ea331981f6f352ee0bad14c89568521bc4825155e3c40da7db8e28a9abeacd77640724d77782e7f23932ecc2b271a5d99a26e1231e9489cdd3df4ec227543ea8adacfb9cac84276bebdb3ae79260e6ff8aabcabdc060d9558b0b9c03b0545ee2474e03aba2719d9d2c37421d150113ff2955df52fe56b5e6d1d71ab4d9b72790f8bb867c216938a4fbc5fcec9f6f0c4885f593915aecfe09cf623eeef739d19b8801fb368ac380e6e5c8c52313383831e6b672687b42e1006631eea84ae3f5591621b59f12cfc91911d568a353de05b05f73966094804751e8c446f93015b36ca6a634fff03f4399006a68ed190e2bd98346956f94d7603c12646fb5b320890a457f83fa08a29b57199625bdd86e613a78225c853ef993f3f8d8725fe41af1557c0b78dedd47251373cf9a8e977ee60d12fb0fa102ffac52392f995b206ea4a11678c8b0cac2ff742f9bb7d114080a6f9d90fe80316908f31c868293b2f7d3ef7f354945c4c58b55265d8a3f607141c92df92bf9010e3704862e8bfaa379ab7b852b122c8d84ecfd780074e255d2724e2a3d2cf663f31db984aae9885758979c8610eec1f0acf5995d2424f316de3c47f7878ee32c66d3a0dab60210e60c161d5813cadbbd6f080b072ed6c208464c953a6f13d7e565a86e7f4e82eebce35e23d087646ed27921c5217be921472c2be77c3641d6405118055d070ad64faca3278a06885f5cd09e8c138d59348b670ffa2dae00614ec7648ec7c7659ee20aa251d7d5b4c06866876867821100a45ee43b2f1898713166ab7e803b21e802b111375cf383ea085aeeb272e441495e57d660f34045eca17621d22df6fb24992d3ad50f00f5fbf0a15425113307a975fb2f7befa55bfb5bba69cd27dc62cf62a8883b2485d43a927b99443dfba04b9cca7b58e6f281ef49462573c5f9156741ec2ee563fcb84f7dfa9d28677596e955a80bdc25eea9e7ffedccdc92d0455f85a54eda81307f0dd74680d90427f0c72db856d79ff00243d71e70cf668c44e30c846383bd5eb840ec552493198e3293a58547249e25116db0a87848ed81ad0bade44e3557005ecf20a5528dbffa990b82e9d7dc9ea267b8a5eea7abbe5c9fd300b81b9b9c355fc53a7ff149c983199b204f05e5315b5785f46f962e2c416173e2260b3b966a1726816164e3630019ab47c3891fa853c7abc33c5a0e264ba80ca2062ca6dbfa120f389fe9158d3b0eec2121e1dfad185d87ff5d5cad8ccef5f391fd66328503d030b76a3877c3bb90cb57024444507e6b3871284e461e3d829094f81604d4198f43b9709649c5ebf6c4a45da95133f9f567d1534c9eb7ba431aba229e0eeb17c36faecd0d41c70fe42400f29f2c8ac5db11e05b7325341ea71c3e058d0aa556181730536830a55aa75015709849a99a1451a3b6d18dc51f6e15ddfc898d4c9317f4c8feb0479c6e2602eb5265970aaacbcbdf0ed29720b6c2a5081c8edeb2e940cc749098882cf25ce08049ab2a41d6e27bf7fa1f116a88c14b1b29be2221b637d6dd9399125a69b00dd2d3c6720cd868093d10024fb8807458852bdf814a45cc135a4e95e75a599f8c52928e1382825c0ef2955eae59721c25d4e2d379fd98102e77a2b2019f48f143837dc95ce3e83ca80b8db0457dae0470b0d8a3f2fd569026a3bc088aeb7ef79d527c22309d1990df8507ad2863b419becfd29d8ba794dc8f2315e128e5eabadb9f45db0f4bd2ac6df9733b50b41cc0b55a600580e350ad8b921eb55cd4fd395bce7b697fb41340346479a4f0561448f35cc9972007feedada2ab934667fcead570340af92795817f2902e596f85bce519e1acd634cea7b3e5267f486272b5c64dc0a0cd70a15e04d263ab349a5ef76a5dc1b623f836a35e8e3ce174f9c47d4d4e0413cf177f89449d108780206ccf8134e4ba8fc51fee89d24c47560bccf17d06fe2abb9227324b28f1adf718c05ffb7e4dbe7b6b1e32b31d09167aa48057a18f9030a388ed8447337f7d0d68280e770a0e2fb3c9d93428ecdf2aa0c1d5f61ea137ff7e42e2f7c04a600ca70769192ada1026f376397189acb7b07091d0c574029020d5aa5cc278c1b9ba419fecfc41d899b225818d40e7f940dc22644ec891630082969c48c06bad5c872f02be3ef1c8db165c24cb95941fb4b786ccf7363b6aea8e8829e75f3e1932971e93a13e6e8d32e1dd29bf875e559dc6f37de5953d68cc349e6e053900608f0c8e81caf42dba35633d22283358f67b74f2ec06f6cd477ddf363dc132855120ed92887f37709e70c3f1e3d06a8e5757ab02afa0980593558c4c34587ca1bf5bb8da0f01bd76080c89a08c391f65ef663400f0a8e806c4e4a918e94dcb57fb766863c1e3b3254526ed485aea2f87187456ab367c0247ad6dfa665b11c956ae263ed1bdcc41e8a8e9b6425e4a08f260d1366de5773776f6f36e6337c805dbf2d1f91b8bdf6eac25be8097d2fb2d25c26df8740408c94c8472cf85ed31fb95cf7bfbc96d3a1d44209ca85da7bd617f6ec1470f760ca46479a256d3cd8debe00066ad1db608d6d40a722bf0c108c284ad3c47fc0a19783378f1dacb2e2d827a9ec7ff86918c62824671f686ed79f7a9741e35594a7aec5d0ef119311d1355ad96a885610b87688fa200a9588777f00552e6c6a2129d9c8d38aec9fd4bffacdcc54bb6eb2394e288a931c75b546cba6c2e136ed44a53f4bf3bca461f9d13adbcf59406208ce857d8643c189afd6ef081f6031ccfb2b0497a5ad000292f9c876ca2d91889b312eb26e83a1be2fdaf1e06503dc8b7f217764eb52169d5801606d383c1da7ad2c899cdae1b7cde170dec6990f64c8e541293fcab17268bd6b1ac86b0f7efd806221381e0415eda01f5ca089d2835f385bd4c4a42ce9c9339110191f82c5e985a64def56b18bc15a7428de856a58716a1b14fad4ca4f86a4e5a966a6a9789ccef0e2aee3f245fb8a08bc66cae1afea00de54660e6ba16154806b11c03f245a5bc18f2088a2c5ec9be1b0bc5dbf66f0c137f786914b5a0f922b3958c021864c647bed26fe5ebea8d54c78cf89e8c2ce0e9d098eeda6a590ef8ff46624691678c49b2a150a391e9cbfe16dac3a767bf97e6d04eaf7a53267d03882023a66b32480fa79af9e10d14009b82d15a324fcc916c8ce971b373e7f4875ed1207b126042c1e2ebc0c5631414c9b7588e388028321420cdb80ae71b2bc501f368247cb5cc13ef5d0d12e23a45767be13ca9bcf5db542f992bf3fd0c7e01a215bbd59daa3675b2139fb08bd633d5116895dffc4daf1a1047ce7e4085167a5ec67cb521e3d975d021576968770b3355932239b534b52f6f279d77653bf6a277474161be89d632d382055a0f56490dafe50cb5d7731b8b591a2f7bbcee43c85a2f721b8e0b15fd2944782bffa927c922358dae382630d41d6929a757a40e23a972fda595900574b3298b1637d5b1aea527cef30d2371dd4a65d1ce75021e3cf4c16e79c039be6a219d7a2345813a845a55f7a5d4f46856c5db7b15ed5ed3948b93ef3a3661a9b65ad7c2c1461c355d2e18ca77a2e57b4f8761cf4440e3e0078ce8205eddf5b01ec8032dabc86f43264202a41ab9956b1471eca60c2d9079ce6af67aa4d81acc427190e7935f35ac88fbd62c0eeab07c51ac1a41ecbcdae8b00935459fe36587e737d587eb56027af7b86b9903569495f3125e30b2a7fd0a253def931a1f16491e3e1d42fdd300cbad36e83dc6c31ea4b67d67b94f362dbecccb7b85f59ba7b4d907cb8f9e1554d63a5c3215fb089c11a3706cc1c29c57912265ff83cb69f225f630d9f07d9805d75f8aea724f2c929f6bb1880ecfb0b204443438b8e6e85da4b9bb756230b4beac22ca650cdcccad48b1a2e252d45ad059d1081638701aee404356590d99a5b18615af88a2948696cbe82ed71697011fd154985127c13376126ac212edbd883bef3cac96fe0187cdaeadaf587e3d6172e35d1be274e8032bfec67953818c8ab371775517722900a8664f45b8aa27038dd04fa102152ed40e435236806fab1b75fea0dcd52fc0895fbb2b16612e16865f5604908ad8d633d57594f9279370727389bad3e404b9e3a6168c69a66665716aa444a66701cfc4d1e2a3301e4c9bd09d9f7891905bf888c2a4d68f0a56b1eb43a81649e2b5a96fa8955780d2a86248cedd5448cf3d0b4cddeb89fe57a36cacfa9b35e66e76612e2789aa3e2630f8ea86866651de8210cadee9c1fa0eb60e3f30c8b0092ecf8789415d5a5bfee0cfbaf6372bef5fb57d3b14875ced1764954d6719e674499bd7d1b39cfbcf58338ec3ac03e2090918413dd10de4fcb540a678d5aa9d87f5f582fab3bbd66a7ee654683ac76786219a8bb0c7244312ea89e90573a5ab4a0ca7d9fa9aba4e4ffc45906fb7048e1e0b18c5dad3ac85733d01b1e08e5cbcb678bb06fc5a1f71409a7ecd68a11050eb601e4d6ba16bb166f53993d8f3d0893006eec9a1766c5ec641037d189390519969735c50a472c71f2b4b9534518e03bba28593e82c6dba3ec1341785634cedc83baf93eac87d0376634d8cad773a61fd4dda66a408f24d4f52cdd5666465e56a48a731252f3121e9ebd1552ba9692a0b209740dd5898c09228ca582d7ece9637904ca2905815ed87d9c6de9837a319b0ef3daae1181b586189e078ade9e754879f98ecec349980d97b9b486370419cc64eb2ef606c63664e225d087834f6c548c5ab36f18729cb9bd2da3ff8658bc4ecc419c51105b3e4df7082b599dd22793c1b84e08064c2de4e529c060e7b1b7ed4400e4267b22f9598c338f6993e21a6a72f4f5b5943bbea4881592b73c92c77b772c3e7bd47372d471c3452bae7fb5f8b23dfe66bfca613cc53c3d1fb8c3f2cd62d81562b6bb397d9aa1ba97ff4550e5b09b873bf801e354b24cfe0094c388648cb97b796182f68eceebf6d0d93d369c501172116546258ce80b4b6027db1d43ffe12e7a5122a1be76f62cad9aaa34c29bcdfa54603f72242934267b391a92afaae3876206f313956ce86e1841d3e1cd4b9fa5ec3a85453a960d2e1ffd6d904427f7326f78348550305215bf490981e688b9e6e32ab622b62d0e27782bcbdc5950793f8924a0adfe3529b28c1762db26627b10f472ae9ff45ba0d489baa7b4de0d162bbab28d5b97d1de461d18d6fb6b38befadf74e3a842b17614f128a836b9b69e7b87e8996c4a6b3bf7efab5a422b357a23956d3aa31a5d335adbd7456ffef5b20a33ce961e9f0e0685884a3ff3bb1287474643b0ce53af66328c5cec781f9261a3df4de323a1d78c69f92b65c3649249b4110e381cabf7796b56e651b976aa337ab3da6ad1f75a876d4cd5d1c80ef9fad3e3656b33b15d5c5660b1e4aa04fa544b63a587876ede00490729fdf55882716ad970b6654230613c7973d4ad9225aaa5ba679a9a423dd8d267456ddf31351f16c69d07f991bbb97bd148d13618ae9b8e6319327ff833a9374441e2cbf7ed44d95bd6aceed99f80ab2f8cdad231fbadae1ca709c71ad3b88206b8aac80df943bb49e92d58b6fadbd1016bfbc7267e16e2f5bf5c5adcc7f58968d510ae36718a2bb828b5d9845ea5b22f959ff99d37857f2c8a6a8a11866b85ae73b2ae0379ae69d3bc056da6c3ab1289ac313140fca55d7dd009b91acfecf535716d39f8c20e63aacd9d63b312f1c8b1f6c16c8823ddbac9726940792d13d081011c827678933342ae6b8b9393d1ffb1163676163f5ea851a104c04107917c8cfcbcbbe43191125d982af0184eacdd7ea751f152fb963b07f5c93929b3a663515100d7bb793b91018140aaddfd02dd8119575f063d7c3287ed60ed2fff11d293349d0dfe4f0719311c63b56e0648881d4ac615a9c77d36fc534d7c53bb469ab5ae3eb03663771dd49e9405d9e55925ff6c5caacc6be75e1fa24fc80480ba593539ab95d6ebbb90b35c8510771630dad930a9004f155a4264f0b89ffa96b99dda684ac250d5cc6049ae864e4555a157cbfccf5185d57b161ba32f42ff42f8de386359545dd974f4517654e7cbbaba54652d9412e8191df596c8cd89541c4953c63099e346dd7fd44a9fd179df86d18e3a13223c32c5cb98f717f57656522defa0a52da9ecb934f43ce05af239637dd5f227dbbc7375abcec994bf88dd4fa8ddd8003de81dc3e91ac1ab2da5f40c82e4517832cbf41295f1f0449f5c9044d968a7b938e5b669a98f2885fcd309e6cbee52fe17ee4691c949bea3c61322679f05ac29f022f24ce33c402db9746734362cbf06ef45c0805660bdd1e5272baf8fa8037dd318421df08e9bd43615a174e9ed82e1a37dfc7fd1b6d707bea707520015c3fc340f8fdfebb6e22eb1c70b43138c23d2f5d769ef43d0a60631fffd5ae9e40cb37fd7d7763938247ddeccbb4b016d112f64b4597e74595822d81ff906a58bd02189dadeb11d5686de8b5d2b4f66de9b6f0ca0ffedec31cdbff535f7ba766efddadce33cb716b9162517643ad9150092dea602eb6ff84807a71ae32baa9ad19435abe1ea7d2e9ddd657dbfca70bf52bf73dcc36c0d7b7a2ff537d016ca4ad976cf8d8375753a4f8b06e6e1d3e8d0b391fbd6ccb5e8b238b936a2512076021242964c87b4a2ef4bea586cc1ff5df8d46d11996a277faf470d3b2672749c6b289b37ee5d4bd7aade6c26cc96ab67298d5d17a6f083b469fe199682567bd0de9fe4768022a800b46a1b008b8d50ac6f3dda14d952438443af82cd7088ab27e91f9d0022846ad14827249379bfda4cf7981832a95f1cd55add8f1e43b17b99fa71c3d2e96a8e7a6f43453b836770067aac99695b8dc13c09f6d0ce487482ef00935c656c350e269a348a801ef51829ba1cf3712f4ecb03a62209e540c1a1ff717a1bc273ab2fce8b7f530106c495d9ccc3d5af30591209cc1adf3ff38896d0bdc2aa2dd03d5c0f9f646fb920bfb71270bbf5fba98ab4420409bbadc5126847de4631674f6bb27f0b0ba2f6d89108c8dc2c32e07de05f304b2f452cbcf6df970c0a06d2a745ec9abe0dfd625748ca51f7fd0356df35361b1ef3300716455516b0fa9230bc5eac38ca6c935b1f6d343026a807acee75b467ee81552778ec7f4510adb1011478d2e0baa5f02bcfd4d34a6567d8a402c889d61cea58dc35ed2454b61cc150eb063a1c1fb1dfd21daf3b0dd6b207e5100a2cb820cfba9136e4204f68fe5bcfd47d1aea67f43609c102e89599dd0dc2e6bca70d5b23ab63e333962b728a6bbe09685e33df0c5f5efb20691fb14404d7506d6a8de6740967fe0355ac40dab7d522b68223af975c593366b91f1130e0689149bbeb5325dedafedc5495dec026ab6fda9e6b6a2e66bea8418301c3b9ee88d22e522d3179563aec5e734f7742b0f1372b2ccecb8dbd0b2cac10a230533eced4cab780284a819c5afa8dc6bf2866ebd4aec632d955a20e48231a88c05887d5947f322da1d9a83eccf58e1b17f66cf11ca58dc5a7a3671b62333e6c67740700cef6278c9f33ed676475bac1d322d8081d7f1ad06513728fb67588fdb2578b18c467ef38bf980c46463620aa1f82eb8e60fd82210a985b590c483a3bb7a1365f1dbeba5d40a274aa542e4fed79c942d8c2e45208a557f3f194f4f239e4d1e22dcf16eb24e5f5562a9e709db4417b8b35ee53b4a05daa879e01e4e095592e4a8c5816acccdf9cbc72e55bdf371c88f818990d532aa003539bef247ddb22a48467de499cf601d69103f363cd38f88facd376a3923f4aaa7011328dd4d1536242c978d3d7347b6dc02eaa3d9f3e8c3cabf718eb645b0f52c63561ab442b9d9148879cb229143778505f403941e82dafc9d0f0ae35810d42d300edca8e82ee45bc4c1651c0d7974534eaa76517721f4274cd7604f7583e6f38d302a13925d07290ae0d201faee51c73ee6f667e8d18e405f7d32519b5828d4e2d7cce907a05b4c24e3024a3341a3ec3979a2b202fc2d96d360d5bc613719d1e1329cb9cb7d1036bb6e1d241f1c97a467ee8de977d5ea08b672958e59f6784058d67514d0fa62fb5ae29b33d5bd8b44554f73dc6f4b5ea9c03d16c7dcdeb3cf9ff0caa6ed920a0310c955fc6605d409e550982fa55807dda9acff5cd9121462b69b208a1ce78f86120ef498eebda6524dfca45817d3dfeeebd4784f7f6339cbb582f276d10457bbf18836a91cbe818cc7d7ab960a3a3bcdedf52c62d31a56ddd0f6bbc43c17a750751181785ff0b848ef1cff3ef1489bc27b508c670ab25dd9d319e31250c95973a78cab867e2ebb85fcf231774d8013f2de21353f619964e3ae1e993e5c4a545728e56f1dcc6a152477219798631a35c7c6adff5130f8b7450f5ae67f48735869bba0d050960be11aacc2f85e3c46e947b713aa257c3443c47731d392d5b0b5c00b8b33b72f846f0cb0f04a5a1808778828a9a81c0077a42541fc30875e235a1a2664208652982da9b72ef88c2e9b9c3ed342939d9faa4f401c3c27597fa0fdabbdfeff00d1a27ab0d8a913b945e0841e00d63214995d35845298a846d1dae2ed78a8a5bed6186eec13fd86359231838f0aa581e88d411424f5b19c0dabd02b14b96b632a1583b44b760038166781e31b4019737642b0de56764404b11bd4629d15bc9b42999ef389953ec95d77c441247776bf6d5c31df96a0a427fc9881b53cb52c1a43680f3258dbeae94194bfe820fbfcce6ba332a4545e708e9ecfab9f88c9ba98b6a20e2e355449e4507f9ec3426965cd0f5ef408ac0e8a12847af92c1203fc30591f7f2f5d604181b7a7779a7db4f6316c39166d5fd0c6722e51fe235fac70ab287c2dd4b5fde206d65628274e1111170e3689e197cd577187bb37f279e54e0ec0fe55f154abfb6b401adaa9063bb425f89d79488524a740baf4a68d32dfd15fe01c5ec52a13c79cb46138d4df55bc847c6c71a80e52b355afbe6bd3f4c9d61a56c8a31d8ebb7d8e3c383c08c392be985dd0ae7cda7712167add74a052a5bcb4ed3f36d1750f12e2c3ecd450df9c1dba3d57252c890eb2f5a95fe4cf1c390b621251f18ac45f3c33a037b0ec1c1410046bb9eabdd5ca7bdbed24db321f4ca4601ef420b60ef71c5bc9687bdb8259299acc6fb508e255e722b5f1c23006f59abc8090a49c422c706cc438fc89e95fcbedada445b60f5857c95d3d0ac8af6b38844a3506f8baec6fd365e1dbd2baf98111aa04f2aff87977268a21d770b2af49c2ef902056de00dc8b8fc122e1acc1d7020de20ad6276f06871453c2be3f7245f6929701668b5224f33007104c066a9021367c557984554110fbf5f8158ac7adb3d229ebb936d5732cb1d0d4e81a38c07df6dcee8feb8d53cc9904732e1fab1282bb300bee3574db6bf5ec49a57ff2a5e0a0718d85e0d16659a088b38b673275ca5c43cd0fff3ddd3379230b9449cc1dc7aaa6400eb3f1cf9daadd3c8a47b26310c8209381f07fa8a52580f7522c9cc0a9a3d929b87b838522f1701bb8b581111e1ba59364419adcbd797f0215ef9bda7b8dbeeefdf1c46f92d27853979a7a3f4caa8c8541cf5cae7072f61db4afb9f80c03a527bfa8b249182bf4b2ddfe532cfe0e8fa0062e76f6d11115749b8059ffc0c5a54277b730a608d746a678e2c83421c65612996b99437e354bf85f8bb6360f6a8d3fad2818e030dc2bfbfae3cd4883fe934b35048c9454cddbd7a56876e7291eb746e1d3ca6eabd212ce6ab799dda8c74c5a97962d2a78c752c4941a6e2bb4ca1ca15cf9a4e7273cbdf0dc5d33767cfe51923238734b0cc2a5ecb3c265efb18f2e41f9d6fcb3d3d50c98f5a9cb92b836c89f805e588e6644bdae2a2405c1e62e2e1124c2793e3496e994144a1675407502fe4bdb9da4be6219fe0be6bdf13cc882800ee8107a98b771e9365fc009df55428ae31407e914bdb568401ae17cbe7121850508855aba7190466bb5acd4e040cc235242e2d912fd5e91eb35c765c5c66763bfc1780a803692b1d1b5d080fdfd80ff745ce060aee9e86cf92f3e4f2d0e8dab95f463a88678937cdd2ce6f6e3d23dd9a2e4deb29c87f70402be3e309f53bbb64fe3101335e337b103cd3ed76b45ca28490b8f40b22989d3373ed1e6a3ff97504a1232ab1aa8d8c872c4e8bd88170d4ebf8cec3e9b86b557d3801a12cd236af65de3fb58598c4fd680f051faefd4aa0ddcb8a7efedcfa298911c4b559d5e73dead5eb6e84198954756ba96e6a54b79d5827dea37339a0b1a8cb6b870d2a53db7da19a8c549db5af1ecd4e23b19ffd51ceea322b5d6a81aa7f55328ac491f4739483222bd20c09a22de0afc51830b49edc5b671ac6ac8b1ae524b495a8beb88045be83f45cc35c1305716b22dbbaf4e333e83272f96a67d7198da004a51dbbcd5e94ebb68ff5ac51275d199cda6f65214a22ed750959953ad2963ce163e4342598c680e521013ecd69c685b388f5923fc01adf68b581bea4198dc6cc9cb96b0f4a9b15f297664719a2aad4f5c8823453e04ccf9e3e9d9b6b74ae8676e490afd5b3a560f305cbd467d0e12adb32dce62c477f4ac283731d660926ed9c5360fd1ba3155d08e3c01307fcb85ca31b9954de3fb9784d157e8234a84a218eefc1bb3e7004a61c502d09ce1caeda32df826180612f528645f7b911ccbdf75543d76b6927804b4cc57ab57d9fc9e9be9a773ceee7515af912ea6b40f6611ee75a71c221416ea6409bdd48be1d4fe595b96063ff206ce51a64af9373eaf4bf290ae448c7d0446483f299cc804db54261bf27dcb2394f6d2fc42897278dbf930e7a39a8bf8bcef603726c1f46c4d7167d0b72b0be5b8e4b42300482f36c8e0373df76e3b72d9448fdbbfd1b2956ec4e19fc0dbc23918495a55f489d5d6231954a6bba6087fc60fa4629397beebaa17db4b58ea20d3c819890a986192613b3fab972bbebda3ca4f1be30faba2b8e40add205e8470438878cc232cf832eac5553bba66456d592d99b6675da765d598ad0c1b5b8405b9b0988b6c6ceb682f2747d9e50d6755617d373b81d91ba6863f44801cd3f6fa193945d85bbdc23399f02ee9fc16e177c1ab092df52a8e846b9cdba7116c183116dbc0b7d774dad12fcc8ef53801ab8e191fffd53e15bb98ab0567b9ca6aa40f453eb3d9e87a66db946597c712d1d9313d92f595933a2b5760267f445def59d3285be5bc8bfeca2b38974cb777598cce943028a32c342bfba7ae27079e24adf5b84f0f04d6e2bb92ec419d14d49c9a29eed6c7fd485178f9837ec8e8b3468ef4d9a8359ee1d5bbeff48200e63a12541e2a7df51e4513e55919cfb27ad9595d7ef2e0b4e525bcb04f39d2f1df8910d0033b263fbbe98d1792194fbf230d06205d7c7d436156b5e1a0f3204f262e2d17ec60116f9dd99e591d036335d69cb2a4c92bcf13b08934df5fd26f22acd760f6f5984f0cbe792f34eb17e752681f8d01be94ca97e993db74e4b30aa53db4f5b34c227061e0d32c0f1daf82a67938abbed867b8a6fa548e231649728f51773a87bb89c7de29cf98ec568e3aac45586c8e29efeb61b15f57769bb4f977f8644536e45a9ef5a74d9ce344306947b392a0f8786e83069b19542de90556963f0b65925f6872d3f41520f47c1aefb8ae690632be869d251528bd7d7fd923572047dbe7da7f6e81dfc0eeaa6f2cb5c4a228773903c4ebe8edb6eba47c9ecdd227eb6ee91c52a46c41161be3e2fabf83a30cbef9763ecbfb2b02b8d99457695c58ec2eabca304402239cbcd4cbb4a77352b5a44486afdb8227e92767713072cbfeba594f35c99e36f77ffabc4a7b7c88f9907b9dd2b77df68ded9dbda6df4dc1c55ae9e13292e2a0fce660f0a71e50615779a2dd0643b50b71d6c393bd326326a782e986b87635d71b968b12b5b7845fcc662e1084245ec8e045c6a69acc0bb5d8f038ab89986c4a056e1b35ed0522525ccaffb9c2c7e2050bce5dc24f490bcd9d73aaca1231461f4c35a9c6e9d14bb781902df5c419e7bd7cdacc778ddc3e3c65b18a8f7d830ca4d3c28232f5076e02a3a74aadbeb884df20c817f1498d4488279d6d80e50b1548a2fce3c685ae5df85d8f828801505698a65b07b6752bd1156aebe0578784cd2370365b71c5022935bc1dffac6ad3c3a7515529792531d37f708c71922d524d536f6562960f925aaa2afc8c452d3e3264fb6eaa827ed1bd74931390679c7efd3d81fa553c50dfbeec8eed9d1f89c0bb7577de439b85e4cb4ee4c2fadf027fcc396056bfb84f4ce75ba698a99bcf2b58b115d761e0b4a507d782eb2126633c657c500ea619855a01dd58e9ee91ed70d2be571ece4a6f365853a2b41fd825b16ed470660974e50f6426404938e6794549097576486ac30ac72fa161acac9f3853b6081adde3728d543075c842e45218e03ac500975f0acb553390342809998ae49bd8cbbdf596000a0ea4c7a841f4f78f32a7f06593158acd5d84b0829c24fd274d0383a64787ba8fff7ca0f9cacd9000331c4de9cb738b44e426cb6c57977e3e3b07b1e7eccd13138391e899f80197e66d78a5ba7f12769bc3d75c65ade18ee199ccf8463b9faf86592406fdc8d5f028ccde973d2bc88552b188f7fc9f15f3e099cb6ffd03bcb6d786ad668a1a16c515164a52eb2b754f0a24df971e8fac98b7563c868388c282e53f8f64862d69c247a3590f70cffd1d6569293ba997e79a7bbb9dd6b142945e19002333312c12527939232733bda2cb99b3ceaee2ecee904aaa16eed1b4084853da432f3ccc7d3a427f2d72c7175a80bc81cef1b0599ef66a1543de6f5d2229b5bacd0aa992500c12eb0af890966fc414602e015f68b50e28ee445f7e6511ab0e1d4497b394c3bd69a4d6b7ae3338cd1aec8893fda3bf1dcbe9d9c1be3aca09e0b7db946761f57c32d6768ad897d0b0e7933e906bac8fd6ac8f4c6d3b4c8c6f8e8852e712319de8b0ffbd750362fc835e22b82db73623f606c366b1816bb3539fed3fe80f0d3812ffedd278da76d09fcadc44b40a17c8e979e235b1c8cf1787f0624933a0a6bcbbfadf9d360d0589aea1b3d7b1af77ce2adb6c776c27378214d9640d98ea59d1499c3285003224411fd35c58a4ce5fbdc703613a94ccb627f9fdb9fba19ea9c7a73f6204d93fba2994a8e29ae7c6a3dc324a22402058f424b62acd833de2c5a38d1d5aae8c496cc4292fb9c44d1d4e02e96c2ae762f0662370018f6cb0084dc752da6e49b6933aa99b3902220fa0fff93408639b93b96c87c62b66cf0221cfceeef76c4838adf2cc1e1aa023acf5ef6dc99b48c1bfc79ead27d6aa90d732c2d2f89cfc947280fd9f7fa25985e126cd82418d2f7382b316b45473c099fe11b2f553512706d881c57d3c3e9b5f3a2456974291aa9bd2bea22fa95e1042f7088163f5cb7228e41d9e4d7fa7430deedcc334d5d1d6f4a09719e0edf5a8840138c169ba8d25c4beca7bce9333f5d7d110d78b68010251aa41698dda4bedd47ec2f937776f67a1a203a52f127dbaae38dc9b0d5042059593db21614a3f71d012b26a2d5c677098dee4459beabe5ee0391e7ab8c3dc5ec179c5f67b78b1ab1e9d37861c83ffb0ab41cb189dd79a18dd41ddb8cf2b36638c97e8bc01408e5d30d643e039bcc400eb747d152e634b7f7689a73da0a7ca864a02264c6899b28b329fda74c9b51ec27e3d87b005452a267d478fd71364b376155665c7e3e3aa8ed5beb4d5443a694ee25e5af09b0f4e5c7b11477d894185cb35b4109b74e0a1f277548de744fe488ed1195e67d2b000e8faa4731d893d0f3cc72a293af4b298596944e43de3bff54b3b41053f3ec6cfc6a598cb9e3e19ee4b281e8d9ee2a18c03070c9c444c8ed11086a272102ec4bb86f1fb4d3ab744f24404223ec679defa8db26754664b108e77518a364f2752585927c7baf43ded287958dcb941cf869c557bd990685d2fd0ea7c11de952ede10855c266d8182ad65f37a85b314072cb7eb3482408691d579439d920ac12bfa6d34b0d8b2e342ab9d0d37850b9112854aa1a6eab4d87720d8db3b9336eeeebcaa7a4073feeca622e0dc3264e29cd433744099a2666d66fa9475a3ae83c9921c8fc3bccb71738c0862ac2abe7e59c13dd869604b13af377149417917928fb67c45d4a6548efa8f880b4c42d6fcf48574ffc102b5ded1203427e5f0ec5a4ab2e525dde72d51fedb19f2b6e3ef9b11c922ec6c9e69273970d89b5c271dba7dce105c95fa300947c6f309774775969f8d89228e35e869ba2a2a8e3d96572a58a751520b733e17e97ab98f8aa6d2a5658050ac16b2d1849970cc27776322f485487766979756406dcac3e611710fd90a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9783c88f2bcefdf2f472c99b745fc1d1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
