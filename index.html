
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <link rel="icon" href="melete-logo.png" type="image/png">
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #997f5b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">

                    <img src="melete-logo.png" alt="Melete" style="display:block; margin:0 auto 30px; max-width:150px;">

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Melete Energy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"750d63c5cbe9918120e302d047282420a8d0da4332f5288e8c1c7eaf25f5dd8116a00890b0cecb22c98126ee53dbb334730c956e917804642a661370b8b9b481ac02044a44c9dadb05895f87d8b52abca930c1e98c2004f7dd4e171526a8121e156c3bb9ba8b116f01a0262f9c56435ce23d6ace878e3103e182cfad03106cd962bfce8e2343ce0efeaee9b1f83dad66356e1c149e38189be3010777f611b9f32e2f29d249fd9f60686c36bd7fbbfc5612230e5738f5bd781a7628ee0da4183e5775cc57dde943b1ed5e8a69236c65ecd8b997ad59e9049a81cce9f5503e0accc4fe8d369dd4b6382d5182ff8df5ca20f37f125da076086451c5c9c6d9fd34cae91fc0101aea8fd8609df5b7f3983ed834ca58f8da3501ca5ce1f90cba894e54a22cdf250521cee583572771f4bf453a7d93fcee66e7a68679e1e25055068c4fd7bbd1ff24243ce70614b54f01dd5e4dd41cb0871b5801dbdb99bb3762e60a5a30eeee6b8bfd7dfea3080487e35547b2c1ed4d1cc57ba4e049471463405a46114802f126f7c58de6b553378b454cacde78fbf263d303f1ed4d907d00b8e085a474cf51710d4ebf95b03a24fd71252ae806311ac6b7e645e3b931e2a884c7b9ac0819a8e995da7fd8e7d3aca9cf7f462ae70615a0b93a5e91cac370cd1d619122c9bac55b0befb8162dcf4365842cefa24d0f2bfd4ab29881dec61d9ae28b1dfd49e3595f85acadaaf5113a70cdaeb02018bff51559808a149b79777442ea3524e0d84876a548759de625b312726fe6655dddfe92d78aa7d3c5db750159ff9724d5684924ab98ff32070617254591b56d470684083c5c67daca3a227d0e84d4353a67cc4418aa8f951980d2bb49dc23d84a99da24460c4a68ce1c094c724d730489ea5324b54d87f6e7da52cdcfe75b299f6ebed3d89aa8597fc622c7b6e3cfa30ee3b2b519cd27c53c8bd16269da970077e74d767b82e03ae53fba00956e7c69f8bfb7b60859d8ee543383042589a8ac19fa7a7aaacbed89107fb210fb51f1fbd8353d4d085ddd87c69e28f86633c4175e6c9551655631065972c21aaacf488bd280f51ca6dac6fcd57a4a5a98c34340a7e794ff27639b9f5ef8a7b466e98c9946f88441b7270d8f2fd753160025ac5706506e4f8bd6151fc880a11958b6253b9bac9a4b4c1010a6fe1d1ea241510cfc1a6f0c210ee320de68ba936dd6f217003ee6de1069ae2d6d6ca8831393ddd32352ce2ccb483eae5264e0f2c55de4196d67729b5a5f13e44ce3685369f891dc7b5443c8f04a32281f550e6d16354617338b99958258b432b8b30484de52f80e6539365ee68cd65c45ef4f36823de757c10b66e35b8b0796bb2e0b4ed5d5344f01a87c9818340ae08b1a7cf2e6973a11ba6387ca81cba3cebc16d055600003ed886598371c2a4602fe08e6b199ca0d087caaa7b4e9b5b33325bc50c0bf768fa3e52235edfc3572cdea66490919a3f99ba485867d180830577d48ae6c1bf6f102d5678a278b9b91667debd045add68a3cb8edeebb60c47e3c2cafb69f7e6f85334245f3bd8d3c71cd74804b1159f6b102bca51593ca9a60b8adf7343078c5594e89cb2c7a23ca182f1b1d5473fe90fa7013bf1ec8ac1205f0043feff3cca1ae99be84b382059a8a86dcf707037171dfcd8eb4d4ef87d587a565240858c6bc80c4d3ff7e6c19d3fe43ad9a5f3ae9bc66c490c1cfaa70672aadddc30f621663babfb011d17b09a31460584c1066fedaeab67b131d13da14e6302251e792bfa8fe1951941d31ef76eaac0390fa413d8f41e587f38069ab44cdb1d9be548adc7aa0e12ba1aa685cf4fb3cdb4f00b0a95d32a7f7b8bfb6e3cf2aa820b507afc086f2d315cf9d065c73f5482c64e507a1ee2b54732a01033f2202e6a83bd296e762adfe0fd26e21bd37208b4f76b44dbe22ec97e6a2c3cbd0a9aa93e0ff832b1fec0e3798c7770d79ec230401cf72571751a7f1cd50696ba59ab689661c2e0505b6683cbc75083edf6008d9199a93d9f502039f439f4937d23126c18f682e804972b231ea22feea4e53c19f2e6bdd428b617b6a0dae31fbeac6c22a6392834dc56491e5383fa3965d940b69fc9e89a8c0ff42fb9d931c658fd8765756a25950a07f1ae21c283f3b06312974b3adc419298a5650cc1c8419c322a7b81e31a7cb3bf7fcc5af7354575bb4a51c97fbc18aecc06b4b9c3ddda0c86c0921545f7d2818e0f9ab0f334d2c08b6bef277f1e300cc3c47ab72fd2c9d60356cfb288f80542d9065c3a57137ca1fbc1603ae072dc294b5f136424891f076de62c2fd2b0fd36e3e800fe291eaea8563618a2776103d99619aa53cfa51654b477e427a38631f8b663552f7b173a81a94dd89e3eb1fa621860fb27b4433fe81e7e7a67256f5279c1b5dc7ddcf343dcb2fc19003df6f0aed07712b326ae8054b5f75573439a61f401fd15c3f067460fe51996abcc560793643a75ed463a0a3142e7c72e113639f07f15d449be9dc24583b9af7f180ce97b706de32ea399d9ea7146761c725ce561d7b799c4e6b3ec9d06d23c42b41a4c0ed2b824097b5c07c6b78c65f0f7b55a9c66ffb211b0d8f9980156876128ba41884252625530b877e91c98a6f471ff9f6c5dc8475934eb842ca5ee7fd789c52609acc3c71f437c025d47faeb1fe7ff9715eb4d70b7b62d3f409644e076a261f44bb8174d7259b105aaaa3be5f7f7a5acd6f27d6a1a2b43d16c4fd718b98c6a2733c3686ae14c74cd300f148b6d4c03fe873cd9c845720928b0265ba2c0b236c49aed42072cb1c7c95bce4a1771305f197089820ea33c887855232a90419c4db22120d56da11d83c23dbb5228593286c1573b757214aa16545ac49ee53576c8284f38697d97ed390ff2d74db8344e07ef0bec676934f003c8e1c2dd33cdeb44f57de5c14e4eec059d4443419c1cb8b6131b81693ac1719581e09f19786d559daa0e71c8b96c4bbffc7335cface71aaef2521755678ba8940f78b544a4c19558e3c971b11f731fd3757352d873f65dea5adea03089b72dbeb23e727cd8bd416cda2489a167f8b3df8fd2ccccde794c5364bfd508559af4a434663f1a02ef9f15a9029d5b61559140c8bb1773c2335e2e248606807cdeed550543196c2111a5606782904194cb4c7547404223a63fbed2cf37f46e3b74f34b7e1401841ae6b0def07ca3126df48c73a9bccd1ceb029c209295e16594288c385aad8d17974f51c736585168a4d8faedea87bcca45b65fbc00b0f18e56024549f2bf6ee8992628d3a5e778a7bcff509f3e1f60cccb3b2e49855e8beff7f4a51d374947d5e257bbfcb736a5b4c0fde7cc8ba553224a00ac6547efc2fd006fde4e6a2869862c3146ae802b8dc58f8c784f4541d7f6936698c8cfc899e8a03c0126bca5e0d236aaae610943ad98106223da086f565665fbc0cbd1cca08507c31cee9514c39fc9f74ccc54945fe3c45e2f331e60bdd89c08acbd54d192f259549ad086acd435e129f88370c3d386cc201d8c159cb3f48392eaa4303bf50195f87c1176d3d0ed96ea14b687422e21a659d2fcc4337d1c12713dd614abb81a185f85fe5dd43f4e45d93dd09fd43c34141444f4136017953359ce28bdf37de0bf504951532ef6c04d4f8e720abaa283292909aaf72b17a54d316812118429545aa01cb92881aefbe1609860fd5186d1ef537088d4e7d50ae49cb4c87ca7623fed5d5fb8c2c365d8e6bc106c6e9620cb9fb20b19f3b48253678ed401c1f77b47efe166c9886bd316c13cf962684270c18cb62172aa2726627ca96294e69c2ec353d42c86802f336edbb92f1813539bcd8f1f10e5aff2df1cdf343eded6ccd8f577524dd0468868b72c85390d776528a347bcaf9c4fba1087251e9b6c3a84f59de4a448415dc19d78dc2a38276093a031e268f6c8d5d11f833ea50a9f08bcf1da1829b59dbf9b66f7c782f583d0e093c2c2a5894ed7ff8b6bba76e43bc279cbc1d3f917f3594e48e37805034078b3c8d84aafaec9cb02b2aa82e17c06fd7ca76fd8736e0c12ed0a03fa6226e94f084334159953ea4dd70161c0fcc4519d17c400820b5cab693ccc65f6fba49232343064b6257af6b2a0c696b814f99f9dc359b47cd21115a81d45bb44b8bd6ad6054c0ad77ca9881a1b750553fc7199b627c908c3569482cf21e51d15b9edacca728bfeb6ee736793ac7b4d69f5750a4af6830be8ee962473d21361173c5c1208fb25a556ec693a7ef49cedb0a08228bfa290b65c5423465481b696204160c846685e91a20ca66e04a1ae36d6c7f5d6c7cb47a5912eb87a0be9bb7e20e15e8024b8b610f63d461779418b57f4b87eaa1f5108de7eca908940b90f1688cbbfa8c7157bd735a9689a1f17bdfb4ce6c147ab1c5295c3ad39384eba17c28181d34483b93b643f033c32d39d5cd150c67cf9d20e04b5747328c01ecdb5aa1d81b1f0698bba6bd1824b65253c7173c9ae1f9de9b9ac608eed195f8336c7d31be5812d3f2f22c509721dd19e7aecaae8140e8c6a3625131efb6718c5620d5156926a32d9815fc8f9ee217bcf7753c33e88f232a8d834b1e716b374706a95a57f450a80edba5b01647bcacef35bfb3d5e82987e1ca3cb0789830dba69f143c5706f245475f2ab9c5bbe6a1d2fd49b291157b20bd454f49775d85a9c9ff9bb323edfe95e4a3471e130fc55066ec6e8e88848438f3382116b349bf0b7a34ad6752b7c073bbab9c3a7104f8a8b4e0443c07494cc33d83b09f3140032cfb82353bea973127c64115c41a85eb1c60acd390f4e7ac104e4d4632549e4bb7e6570b6138d4f6bcdb100e002bc4cb0d8be4a76847095a8d698e41145743cf919e641deac0cfe7a8271c82d55e4e28442a23e39ea7f862db7eac44b6f7a7b5cbc27d711af16792075f7283e8810a102ed3dc5f4e672a2385ac923423f9d65b9cb815d51f5e41d979997b070fac6a9f47ddda06a04532ec23e1abf97a4dc7d4c31c72e666dc35a646cdb1193b5766e793a67f0e45a9bc71417abb92e90647a293a72389d58fa254af0222f197531d3ed51313473e4b22b029e9b5400b6368b572cd5f31ee8ed485aee3c5a47a0bf9ca4525a762168b73ebd1795fcf4d6bf2b5f70b256111dcdf7d19059851094333b9a5ac7253d0229505112479adcd44e07f528f945747a258833b75d19ceda9bab0596bd8816f15cfa06033be475611bca14689cf47b39025e9056395b4d48b92b51eaac52dc5d541d08a4e0f7d21f1515077425e673c8ad732db56472300c9b9f54710370105e05af042eec7570ffb8063019aa18eee85e08d42b922977c666e5c12dc1010d9e4e0bca24e831dab853af8c56d8cd18a4f1d8499d2824e753362998143d2abc6700057f792efb047e4c023863eff987b7e35bc7f382a2605dc28149f3fcf1933ad0dcabfc8213b738d5d21b2ff3b941afdeae532ce70e70376fb8cf3486f9c864c442ba9498d2ac1e6c0437b5138e2997e6e9c853875f4bd49f6b2d6964b51ab95b5dbcc883f428d66842d38a1b514d073a2c5a121c0eda9fc5862a12a36f7c8c95c36d3e1328544447f45051a25531b429991ab47f8e383e522fccaa68137bce71fb943d7310f549dd5ca04e51020ff08e0e130d7631a0e9cd3597b4b4b247223302841f568d2296d19d4bf921a7258db8bdd0bf18439bf16175b46aa89dc24f922c3fa26541883a43e107c69e623d2433aade8227cd0c152f89829bb79b2f12e2ce9a45298ffc391ef73dff2dc8c65b00fc77339430d43f3955f743d6be55a6bd674b8c2e7231275e242ffc77e012e43d71c24650fecdf6d6722531dc800625642038bc5c85bcd8ff416383e8e503c07debdf62113c3b35f2bd2d2d8464577674059d1bb9ef71d4c46d71801c9be42ca69ff6c90f92e89a42cad85162633c9f83566ad7c2b4ad1471e1c59872dcfbcff56fb0de923187609d6922536cf01e4e3574f13e3d0d897563f1bc4bf712444d31f93cdd00fc4836b66ab3f3de5b62f55f6fdabeb18d7612fa07b28b12d87a0cda0b67c3c0528990c116b7d220a6b2d8ddc9313e7487feafb4ff33d3077c8cc4e0a20cdc80cc5beb97c7d183d121788b586c55e3aa11be4acdd6da8fec9248dbbfd201d3cbea5835a8fb78899db62e6b4540edc7e4f6b264c552f0973f5ed0fcb9e9378f1b09339346d48fbe98de96cb3a872cc133717c6d6ab3477f6f1a2cb1190d6da6df2f7940ff03d0d40f550d5ad959548bf201db848b7d04e327de51e619d32d3b8e9bbbc68de9ca152d233a4dc5ab7ef61f62dfac72adab54e07de9149e1ca22621893813f1af040dbc53cfa19b7889935a3c5c1fb28cdf3efc82acd61ff55e72fccdddb3ee5b19fa3efbc938456ec1e8aef797ab980c0148e7e9d931f09f14e45f56423f9435030e53d9205193bd1d37c0ca122f35afb0dce16d606ca18d47e2a106100f744ad524803ef02c4f8bb67c2e1aa8023becbea05f43478b79f4f53c624827e754d0ed8e3575e631f1d66d75902bba1b951591a628295e60d9d1b0d1f0603e2c7a31ae87e4ea1704672473cee575fe2575381a0ff6e99c1337452da9f665fd0f0b79f462016ca4977ef8764d9299e058cedc74a0950290855c51adf32e8019cf479553f8275ad082b748c7600a5757e62c4e28e3dcf435bcf08b66dc29e900b4d7d77529673362534bedcea7f567d0a0b8fb5566848060ec4b63854e334baaf8a6d2015d98f14e0efa62bc49cf8011f6f27a8ac6f3ebf131d2279bb0e461caf96070d506ae60ee7cac347ae3a9464106ceda368e8a45aeac093ad15a031321c7cecd6d7a808bbcf2a058b1a21bb05a7b4e11807161668ecedf730fe8d931960a40761353e2ef76b61ef90cb3a20eb0ecb244733a7db8ffdc1c5a5b6c3a70a6705c0d09de0cfdc9d7434788cccb104357e06240f342b7b6c4ff6509aa0c41e5846e3a8d9986559ff5d243ec18738aea96fd72611868122a72ff00f004b559171e5b0232e001d272f87aa23c104e6b435a0ef3283272e4003d7fdce7a1997367f6695ea96bf2ca93d99a193c83cb56b7e202af415b06ab5b91211cc88ae521653e824d0792406c34333abdd26ccb163aa4af69e9ff7773f787d1f77724525a88a21bfdaed2cdbb0c2bafd2b638ee99c9bffaee57c715340689392fc2b275a639a43b720cc40020ebb707cb1f9c8233541034ef26d76ada0cc914985125526187912e1b3760079873d4b487a421094d668bd582fd8f5f7256c2b13ed8be12a80f8426c101a70906e64acfc0b1273f4e567be28544ebd7ed8b9559a0dd59daea99d87fdd8c76b3decd8cef179ac11177ebeb624471e5ce1d9001a86db7bffed3d576fc2441c9529a6f246be7a02e4e998c06778dfa6e7b2b03ccb641090a2560649a9c942d7d14459987b5c93e395acf26770658ee3b02b202cc3d819d6667254ba69a046dff5ef781941902871b0f90e21eda8db903f681c1202fd72fd86f5abc9f4cf1d4a1e130012bc42972542cb8e3e2423e5d95e7ed3047531cee6080933241a7d29ccd8f18e48a515c68e5f855ab0632496c0e60877277cfe0ad27ed50f82b3135e2d88383f2a5bc4db2bbd2ddaba893bd3020b40e2e1a3ff4bcf55902bed8e81d56c2c8b1adf739d979779ab2b5ae6edd652231402e680fdca7ecd04390b0f3a6709433ca581e3fa63dfb02793731bc0aa1ef43607302e4623830729df183dd298c35170dd42348afccf92a099d3c4b98ae2c6533b0cacf33e85518f9ae22a19d921914cd4027ab3734df50c1ae750f53f34a59135b1e062421a4f7f494d3b4d5b6c2550af8c1cea5215bd54d3d1ab88a6e2c947334dd3efb1a49730c129c3ca8e705d735c2aab2e4ebc4f729d19840cdb048d414927a3d84ac68a106815689ed84d4d75fc729b64db0991fad678521b71ddd57d8fd0110b2158338bdc3ca523843b6a5c599f04125ff69374702372cefb1e67c29d704dd96812733e69aeededad83634e0544110cc29d250514050572f382153e45b92a49f8573f463b807920d33741ae21a562e7b790b5fbfef532329aae910e1cdf9153eb3ab3b88aefae3e19a72708ebfcbfa9e25146f36ec97f08b2aae8ccfe36e40718ca4a698a59b8ea95c51e94f4d0e804d08aca31ebf06c3fab813761db65184c6436567fa293c1a1d15c0b8f97fab9060bd3fe94d83d21e61789a649fa26ec63e11c01593a879917933192def604f77af1b39a834c12fa82c2e960a2de58b3d6ac7714550f139f6630e81e6783c02c95c347be7988ca0d4f766a07f4ef0f08cc03a672987681cd7ff4ef6e9748495fc4c6ecd1fc4e5b2f788640e198bcb5a8402c87c3d7a0107d165af1791756d232c9a8e6ef3724aa7d4d51d027880c7fbff04b657783d3f96b5e0f7b6274a354419251128b04b5c52c7862d31b5d444255450a500058ba4fdcc9c45f1f92bcd2289f3de73c66c92b0fefbaa6d709f45e1513d2216837791da7e44e348ced393dd1a0ba39e64df8098280a857a12cbb1d740730530fea5a04326469ef4a71383a5ddb5eb6f13dbebb776731b6a07e04a189e934d28182319d0c6e78f26f6a61ec88518890a3b586d62ce62ca18026e9495930d74822af02d041a5d51b73dae7013b9bcb165e2aa27b445e364fde77ab3a1dd302720fd9a79cb2b1a0d28d35ea6d1d332685d3d61dcfd337a95bb9bb2309d7d58aec9e7790796f77347a51ad85e1ba93d21abc38da7780a75ebafac321e4e437a29302b5ad0407618be3409a53ab93e54f105b3e726f1ee85db23a6790dd6389e7337ef1e5b39c99b8729a79966d4cd1b7156ba44a55034e327b2bc01392e6b874bc54c7f47e6e339438401e9cc99be880b48b5e199a6ba85b59c853c201992c1a5b78150c03868842615611cfe0e78a8dd2700a75fc7530e6c8fc481ab311d7a7da458a9715f39b079f6dbc253fcfa193432adfe26082cf9c3c5c993c9c1caea41b1b2767da67b0fcb11af013302153867d1adcf41cfa509b1cbccd384ff329de7d38e3f96f52a79284ca74a7fba0d1172481774b432433c9e776cf2c9399aa12bc938f51eefbf6cf1b48432101175bc906eaf83f7d0ade55d4aa612ddcc22c0b0995a811b50866d916652ea8b0f4298b4e23b568308a4f26c59d5d7f602758e066a63f45a876de2ca11efd4678d41898a042569a27c62690478c2fc8fc578ac7ce956b2caecca7dbccbd00a430b86fdae0251534c15f6666f5b1696b5c2f68a320276f29ed8b7eaa45300fbbd087bcc1e6fddd95267213df4b6ac08a4a9645b94296ddfd95b819a80d91b72233579970365ae710a284e179cfa811f857d8b9fbd8c5115cb178439b0f78d72b3fea77a5a74bdf6a9e2772d8012d0b3d10e230feb55b0b0006200fe304c501730f9d9dac5f8340b79471f49266dcf635cafc55fd328511fef0af27a95dd4c965d9ddc2e365d008d371a4ce4fef7a39829a1c0cb873aba4553bcbacc154a03f9e666b1516f8759bfe538311de2992902bab12af1842f38bf68b583b06b7cbf582b26e44a0a26dba12ee72577117034ee200f04e5059823f086a6813e58ef1b419edc701e16c711e02d44ad96bdd81bdadc2f3a1d1b6806ca1fbb110e0cbfd7ae1c0471b46762a623fb2e7eec6c406bd4cb9d1f5c15b53fde1bca7b8ece174f825c965608420c774e74c8ada62a4d9d2d119ea2ee14acc6c603ca47c843170b70b6e2034789a6f9d33373a876098095a87950cab3ddfb13429110028f395f26d9943882fa98c719abd3d13111ce79d9d9baf35e765f7f91250a2511ff88d1388fd0c52d25ec52ab927c4e0c273adc193473d9e9c1cb6be230955f5cc902fc69f03d2ade6541d9332077a37721eeb11c58a5b0354bd437633bb3fea73183794d2f90dd1aedc0156e4d8026dee94576893bec81ceab2f7169f221f2ec1fcf70f903bcaef50c26f6469c69274d4ab7ba51ec6cdd764477f6e243d177cca9faeb1ea54a9d23aa87d061db8ff5e9e59ace093b19771085d9c7d30766343557c6da4ccc9e5bf4a153ac76cb44441854cc3838436c38a587b15f59dd7c729874c8fd8a056bd069bdb424845281a73ecb3c423e1b94de3b5824ac8b5a2ec9077d577430e056dd7a269332f557d5825cc819c3e813f69eab3cdb157f67bd8504567ed902dc045dbd3e86e034db1d836f3d8d9342db93a405a5dda4c960251627c3491b517e789a324036fd8b48b3e697def2703cae7cb2207ea7891d648e3dd2f6394d1d420a4e245ad8ef18808921b4e494d0702795f5999535a4d3db6bc1acd94abcb7741a1a7979d0e1fa3d0adffd2a1a2fbeed5e1e843037112f1d2f27bf2070626af17e0c28f686a9d1f015167bfe5bfb8d9038ecb4493d7ac07c889aae950c3ace39e3ee3c1ea8106ce780575f2fd502a60f6253d7dc6ac64c91d2ba84f4576843290318a9a8f7fa44c325c758c9b68adf56f257e3c532dff23d3ed001777063d855138423d13c8fdea8a495bba51b41bde846022673463510ac17c399b24c7a28bc4bc55e1530504ac8505b765d2196c93e9f57d1eb8512bda6ad077954b381a9d8381d7fe848ad34588b0ff22d6da6e469ce5aca48cfe859545d5a47439688250b7a4f67edf06ce6bc6075ecc8c160e5798023a0c5a09b58f179c812a98661e682ce3a0b380d619dd0822a7cc2b5801d86748bcd26068b8f968e014253648f59b3e628a9f71deb1983499a8e72c29864753ea8f3e0ca067beb1c0ba1f3c42b54deaffaa92b67a61ae50f849d06bafe822acbd7810a0e6c62b69850ab32f88948ed4ebaca9ac9e420bb4a206a8b7205c015aceb0b11dc928ca32f3bc91480312816a809e8ee0dcbaba1dcdfdf1b139312691048253b869c9f03d3686df04a89c0532e65df95b6d792f06969c2908f8f23222a306539addbf644fd6ccbe001533464837e95bb2499b6e5f397d44864714c5d9e786906ddb6365e341819dafbb6ad1014490f8a35426f7bf4c02b87299c154bc6eced9738cf51a8fb07a17ffb91e3850b896dee5d50cfa689ee56f4fb3ffbcf80d9a8321aede500ae412ecf11555aa36230c028b51d5a3f78a6d742c8538961b5f875405d2cc753215422f743449bb4a8c5326e7f954283383516e61058b2203c972478b873a9ac45bd55001180bda243007be16be4043e81a229191d2a7d1310d56e2300f64d6cf17d213aa4e27120552216aadce4ed9a7373e5646a9af0a2010b52f42f2b830fadcd70803d3d9968ffd53ae9cf17dd6826731482c23559614574d4b3e28991162aaa2f7c6245f262ea4acf2018e684a7d18306e06462e1b275a48662e374934b42415ac415ca996ddf551c05492f95f3be05ff7f2282ccfffc35d07fed7d7aed3020b06d743e366514fbfb5a4cebbacb15f461d84f4a898183c72855847c85ac4f9eb11c874639a6625772152377e35fdc54d548d5d637106e0d51b5d98810b23de9b27d3c606065d03ecfdac27da9536a4e8604f8acf0b67f37e22b24e4ffe3627a9a97881f5f7159b5f5a187a921c8144c2e10eb4a1204cb657a591a5ad9479553429fb0104ae08ca0fe0b5ad10c5016aebeca768eec68d8a8ef393190ff5744c9922e40e449bf05be56c9bf4aab769a5068aed8d6319a21908cffb8713dc5384b5612c682046ff27990d1b476001b67031a99bff40ddf9002175c8a886c2ded4007f3555568a0e9970ce6dd449de68f5c02ac62b81e8ac970f7f2823aec1ea4d5ee25877e672dbb1e0ef449d6aa83767969fc136b38183e9920bfbfc26e2d38b974982b58a6afbbb4f2f5633c6aab3332b5d68d31405f7d0609af1533a7797c24cd1faf73baef0c97110c7af18c42dc6eef8a5583af6cb541802b0a6f7cb3ba9625b4b3735c9db027365f3dea2854e813aa1490fa612f390f52be8e4cf3b671044fd2e7f00a5f65a319260b07405b3b22cf2d171af66684340c4d5acaf594e1886285539a6bbaf85f5162f4a2a3624f31ad6b58c6c6aab31eabb7c0f78ae3475fa69d72aee190ff147706d2a99c316c101b8bc57ed0b49c827955a41c77a8fcbe8fda7f80f7d6ac87146d079fac74e1a926d34ea4663a4943c4397da00125e20a4ebf8ab9db55eec7923773dbc5707769d259f3a3ae18aa1c431da00328f156088c249c3a95ebfe177cf33cbabbf32aed709d1185e1d4f4b5511475cba421f9ee4ec11aed2343b89e2f6fb7f9a163b7e92ba2a8d0aa3de459aef3c7dd8bae6ea8a36c17df166c0f6cc4daa4c4cecbeecaa00d2b89117030ea1f400573db921667c6660a15e925d1545fec089831bb5f792bdef720a480c5bb2490b1717c11e9761b9b12de7c9de7f868e0aa477952be64564b8781541b75b063240132e5307a4849abf262def72b433649e0aef5010b7639491527255c7766c5c3ea128e1caa4b314b36c062d7e899cbc199c2851a7df2970bd3d31f930f1838a99f8911d1937090966a1bd896fe0323bc51134631d7d092c7fbc510404807adb7bdc28f7e4453eb866c70db856bccbe793c5af24dca66e264d466c7c2c37e1654eef122042141667bb6ba6f7da7b410e49a152a6b716ee0c4a9afbc8454303d1428f149d515d3ed599d7d65925431d723d3886a2f5b91a00166cac5b43e7b1d50ac569fc35307b51ec6c1142877ca9eaa54743d35384c285cea5a2afe451d3787e3934944954a7b2c6df4a36db4c8b8ca8379504d0c82f9bb9b21d290afbfbeab80d643cc91804df28b41f0d3913fcec921194ee3d0e42396e1efb642576cb196cf862cb0e4bf8a63280fa5f0e7f76044fa8f6df18203188e31b6b33218e43f95eaf3238b94c80fbe6bb7963a709ee960219eb0ff37cb40cd71eb9e0303eadcca16b83874083a6971dc77a7dac1061647f21f7614ef6624265c7aae926d989d735e5b8ef27a0308315a0b7f97ff3cbe2d46e10c123ad678497afd132c702d8d40447397a6d56f52c0d86c187375b0e2c373b130062a99fd38a3da7760bacd0bb68375eea449127809472d5bd93c30b58768d40d567d37da5536d58c824f8ab40e3b68e88b03ce8abbd8b34efe3d5e5a3c9ef01816e063fb2cb777608386c9e282668972ffb85b0af87c0e00f4befc2cfc374ec914c87568005713be19d9636c2fe15b7ca25a309bae579f465238513158b6661c1733d271d44e56402122be10a9264841d2ef03e325bb39420e9ecf8163afb5f4a8d3621a0762c9a230bf5ba17834ab24adf2378c3b937f488ca22da76a7ceaf1bb59baccc7caf97694656374ee65f46b32d562d4c62f5fbd2e91ebeb108b735b0312fd6370e4935139e440071de564b5b35de50fea0cb3605e743b6913107f4bd2084831aeb51a081ba29934fe12ed35e01fae3d84699682833f291e4446f49ed3b8e14c9ee0b93efb4230de51bc45bf805561091efcb8aead4b2d0d65f4137887c77cb09dcbba5fdfa80b6888d1efe7087f67417d557c52536b916f8ade798d76e70cbf62fa6ab2e260cc967266dcd640975172525f6bbed71d019087c66846970a3f686cb4b7bbab9e3e654f21cde6a27a32c016cafd9cd2fd6a020a70656eeaa42e292474419a9659fff124c369d326a918a17e5cf55ecf96832f9349ee5b457645d587b431e61ea2f08c1c73bd1c1fb64aa39b343f856a5d859e7744511da5e012bc0c65c3b9cc7516e3f73a5ab35d7c9dbe46eaba1879faa8a58136b76846c48be0ff028cac271af6bc73cc64ddab7d111789a3dc1d020bfb8f6673938ab4ac377830d4dc30e68670b185bf2cc189cec019f539dd7f96a4178f9a5d6d4aba033cc4aa68c95c024f829553c60a02b6e1ce4062503ad1d26fd1b98b3204cadf1e8f6c4bc28e414d185d89993905222f941f1879fbb09051269031650cbe8b9bc52de5e2bfc7e97b44dde79c491236cdd002c2e38f568fa9ca7462a5c8cb5165f8f9e867a4059488ce7528aa0e626728ab6281b7a39ddcac34c8d71e9af8b65287fa094934e62f680f9427a1ab6f7630d9aece320b531087ace35745f960328ce517959220332068a1cdb7b717822390c4b556992767b33dade09ee1000f5cb07f5703523c93c805f3c886c889222039f9ec3b01410bf856156c6e243bb326a36b83632b65e7f9a6c20c2cf97861f7961da3da3c982f7feaf6a549562c80e421dd690076826e2383b2a6478a9b1d5b495ce5cf7405a05b8918ad46ac48928c15d7b7fce56225a11db8fa3cf2e2f89d676e64a72932eeb8550c578f72f8ca3258fcb5ec38e8a4f9414a1f4eee12a2da7b251c9aaa7c8177a04fab239010dadea644dcec1978e45c6ed44b9fd46d12eb2fc0e8c4448db65ca47d74b71c15eb2cb6c6113624fa930ee703966323976d9d5ee7a15fbc1968c967688f5fb67582bb271e8a38926d3ba25aa52ae12b4da22fed90c4c63cab1fec97cdaafb7e8e7ea0dfb1b57181e2bcf2eaee943a18234e702125fdbdb06048b90886c65a5e945869861d5e4e1565e3354298e148ae0b9076ddbb6d657b893e58578e70f0b51e14f66095f7dc849d84a9973d2cd7e601c09676e6f97de3407b95df254e95c89ba20f7d9299ce7f440ed9d622dd552c17beef07c171a798878d4a30100ced00434e892a14625483658f66a8e044d5a2a083d6c9d5ae5fe7b71db01be6506b3e1488f96402ed1d2137a4ce797bde219f73dab7e03698f83c125757c3c67331f688759ecc84cbbad9c1dd7f2b4a7d33ea04e0081fac8018c6cb5937e29641064375f9c53660b58c775d96f6dafbec4e250bcee4dfd610437b85e15e8ef10922cf1cb7b070bdf01887b5fc21ee0be9085a4ca4a5d7d60fc77be9fb0638e3b6c7624186df7e5847486a107a1688292a1aa500783cefc74630f6e7b79cc2f46fe5cdefbf399114626c0315a34dc49c9ebad4781c1593b824b28fabb940194504612e9fdc8c31ab2c4c01ee5243900a3b4e9f9eaa1afb69f9639ae30dc33eb94191347c6d91317aff515e5e3647a9d735709a09cb1c13637297af1156c90b92acfa1e7e80de1071abf6241e25553b8dfff2ca708117d6b72238ba1d30938c32920f13bb69519dc975a6540d5a88088f212b9fa231a28d27620ee3dcb11ffc6c8231e36f81ead541874044ea9e0a36be8a68759eb2517d1fad32adc56a9f442255b2732644928e190c0dfb68f0d332e1d64bc0c0805b814c886f0081dba63735d6939b3d72dc853f0f604e52a97ebe26fef0d3d803a08739befdac5847f6977c382e357ea5cc1143d4a17875f50eb24c29745e7c698de7f7457c03a911d7f120af0066b3a410d0b7e8bc3b98784fc69e4c09ae9588de824eb425997a2e29308d3d159cbd3035aa899cacb035862dbc18f44aaf8fbdf17b225d3e470d3de4ce781c4f0ea759b8082b638d39dfcf9671fc1104a3715f92be9d8311eb6baedb48f4ca8efef195d93be5bfc58b5a8e51e8fdf019ae57ee3cbbfe3ac2a1cde663bb6876947c326ad5bdd539b2fcc8095b1a9b6b82056d32a1dc9f3329ef09efbaf59ce1e5da817038f721f296376be2ba53caed2aa902b8f1cabb9406dc87f58cb8f73894e693c4fb8093d82cf48caee5aac2f65bedb4139360438a33bc02dbfed7b739fc91a8f47bb5a5fd252c136dd59f81b013462ab2bfb90b7e1f3956d7127af2b99b0f19e46e74b0d2a70e21352a18891e9b52a120f5081ded2862c9b6bfdb1df789247699fe739cb2d8f3a06bd171e07a15cc031b94ca79bbd0d8e8b16c3c2041bb53da799964cccd48be103ad8402db63253b08d296f2c465976f16a276ce01439fa2d3a1c771048fd4327f48a8a249754ed1e7282894b91921b66d3f83da6c0f16920bcd00105f593ee72af66645d4bf94d877ae6fa238767064065c574ce143e6eb2f4a52b5b0a2562faf2482485867f3efda56adc280bd8802e40050aeaf4372e2f831cc81fc6d256107f9af31d331e0ca681a1b60c409da9b300bd1ea89c93f375c7a72303cb46fca8d4d94a0192cc6129cfc853b987f1e97","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2028c17d0f7f7a00cf7be3f97cfb8117"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
