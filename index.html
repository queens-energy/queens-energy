
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #a06f29;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e51a50d3b50d0e52c07b5657c3e871c00a86d8069167f1bdae427bc7f7312eb56017b39aee708904043ea87020199ae4302ef6f2d1ad71491ee7b036a7e022b1179b733990eb650e2016c8590ae88c3345306d39c1947f2a2e67dc9b4e8088b8d733dc03840c45a3e578ea6b5dfa10201ea05971ce8a499ec10e5afd7fee72432b6a52976f96d3bfdb18b6de5536cb2aac70ed30e1e435cb5b985ff6d99e06f7ba8a9f2558887b25c331f75a7e8f6b93529067c4e77c779cd5c22aa1679fc699ea5a4e59967d5ccf0cd608f427fe14c5f1f32c54ccd74ccc99b00df7659f7c4b68f44529be657235c0b4b6e15290bab82f5a2b798a1e92ec42dd6c72b5d8789f35d5e9b6b3df33158bc0d6f29cee8e2e7c6c597313b64dc557655db0c9e10296be9818d10f97a99adbba689cf05874afd9a9af2247576a956ce686705759f7f340f3bc56f21e4aaf20c29b39e0ad61abcdc8e34388281bbce68270bdb6bf9a10f93e6d5f89b3905c4c5c7874d629a4a9f7e135c474821bc94e10f8f6b31044283cb282db46b127f233c4d958fe68b80bf5efea9ff8c8ae461e4c122295f5ba7eaf3b3acf0ae0ed00c33e4acce290203a589b75562476b169e8aa90d1d0bd30dc96241d83826629025812e47c0903062be0d75cda68053a57234768aae1c44050c9c5fca4bbee65ea7ee5349a701a37bfd832008f03815b2c2aafd66136b6cec4b09704e5a5079165374c9e6c62a96d0d335aae5476d0c4a04242b742f85c14cdc388bc1e539d038196b7db5928e7fa4ddbac3ab79dc53e0180fd71aff12568e35dbcd69b49b28488e07ae92adec5325e7e8cbebf82acb6285363ba2af78f6302a52de62225daa198efde5851f09cdbf2b6d78f62e344ab1a52d582ac2bfc4e4eb7f998363b030b6e07fe88964c90b7efc76e32ecd4e5c4a182b11f7e08ddaf2f4836af5f87dcd7071555bd99163da30be545c8c352e129bc920d089694980d375dace94e0228afbc9c957d08e969435107997330b8809e724e9a2329489dc03fc2937479d9adf7656c741ee40a082c4df2794d2f9277abf5d085424d4db69465bf6af37bd021a53ec8968f43685e50923ee5c7925bc56054770cc7a75ca63b0a6a4b7c486ab3d70f7258415926f818202b03f2969fceb81b317fd2b53d7ddf03701b10653fe6812c0bc30b3e5ff026b3cb79d5a5b4d7c08a0b69d254e2c81dd98cf01ecb1bbefaef9c1a620980ff73a8fe8b285de75e274d6a15fbb52308691650fc51844cd33b06c31c8d01415b19af7e88dc7664d2d34d5744a28583d1d35f96a75e8337026967c11f2ff1142c5f9ed34607556cb41d421f4adbef2e4437601986bb1622981efe98671a384ddbfd1ae9123e11775a02d6bbca4d1eba4f3fa118af14090e97fa399f4218c5177bf517c9186f410e5e9f5119f848f4673a8e2f3b9f87fa828f97fc48fabb64ded8956ae6143b536591c56e69a45e00c27c0f99072f90b3af06f2547071f8f02264caa92edf31b57a3d6bfabd896621aaf97b80e146d05d9eaf8562aba6f2e2cd9742998f0ad3aa8e42764fbbfc55d4c914199b97ef38a4191f9335d6204489031275b73bb4f81dd80168fdff47b22d7895646fab0b80fbdc88a23947994767b21dadf14ec1e357a6c247ccc359a3c23d270eff549565354bb2155ecf452e288df436d61db6a966ce0237382248d6a1973af65d11db5460eb05d68028ec87529a8ba02f206693a629b74ce050fe70cede060477b10d85f39a26addab782cd9ef7e69a7cdce5ff070cc9a4fb019cb4d795ed73cc7dd00386c2cb940eb813e5809e39e0d14594b0b831cda38025eaea66a8ae4153ce16e5c80cb451054795ebe80a7efa7463f62749a486e06e4eac8d6aab3ae1dfdddf8342caec2201a073cad079c07af4c0f625c7bc8f415e5c011a6612818ea0be6d8422788ded562966ffb28c04b9520886e9d20dad9473707ff958287fe1d8fc9dbeaf599c724b86a1e63ef78947f7e8037bb82bf7f3807748a16f1c3ccedca35e0ad62ed79bdfb54fa67838ffd1ec2b906ee53105504e2895731611800d7b2e7ba184ea06cf3aa009a7722feb08d12d59f0a878513cb363617a00345ff5c35a99bdf67aa674424d5efa91f8d7c9dae20f68ace650326562ecc430b803029bde34423a933d1aea537c6f0f73836f174fe81d6315920a658bbe730a916bf48a713216c67a733060c83183504e33011b02d13fbbd80300630ac0cc467ba311237405fc12e3559bfb6aa0501fce1178a5524d66771d937dcc5e87bb7c80c65f1be454deb1fd6be161a1b93dbe1709524428771b3ea807be46710f9f8c0658e786b000165747a6ef0ed3706d46b9c3032bea612e2f566f9572b0e5b9e6aaf1b3c16656316b885a40cd876d6cb513dfdb58712d82bc153d9eb67202d9b616919d4262592193f6d9651a5124a95a8247f5750fb12a94e5e3fed39273be015b179e12fb5e2acae4c9215be4bcbd64cf7af7f2be97529a9ab144f9fbeb1255f6892d253deb260574f0e639e13f6706d0771af107a10a1b81538dafdf2164b04eb5690def5d68573a15e370f49e56b9ff23bff7585ae20ea54f43b215e3bc4ebaeb55bce3aa3a5766ba53d0a43228aab16000cd7b3c69c658fadcac8c266bf70eca5c132cb70f70d25349f42cfd0e72720255c7246c1fe92e795a5584200c601ebb04d0195aadea645ba489d3b26b233782aaeebce2ddbd955efb421c3d4e8c61cab29783ca8ba77c512c7c791fed7d0caea775a715f8c3944c213ae23b842511b7689b470d1c12accd9f4068fe5947dab1048492cb099e915b83167bc89c0ba9d3276fd0c868ee35a81da0d79bbaeb8bf7622265af2a0e7a11ce97c2c02acb34d8dc99d01a7b1894fe23f03f9babb4d07005e134506a4e25dc555f44ebc1dffea492ef4e18e1e52529462a439ff409a5caeaa2a09636d1eecfb0a68ebe0474408db47c2115899d504d251bec3401fbf9b60c9d95bed9c962716308a16fc1548b17b2165d182bddb4431baf181929f200dba288c2f3bf66363885b93756a7cab8f3b6435fd84b9c5f9dfa2087da412992b16c055d2f978278d0bd2e5456ca7106a9a366a2d0ad977a89416a82a12b694436b49ecab3cfa5616bad0e6c261c77a366ce2f5a2b965c40225434098d30114c7c9fe36af43fbe4aac2b1833d579236d9a501fc2bac3d2e5262cc51554fab09f54b273c3b354d7fb47ce094a40a719e67c8a22aa29eab58ec30a0f17abbe9655a27ea6981eb34c090f95710a62e3c4fbcde2daf29b73ffb11fbe448ea3f2882e387484613c1a8cf5a18fc02272e44a7d234b519090919c9ce6233a8a63c1dc47a376db9890b79c7f529782ffc2ee46212b4626a4018c48734e0ef50c0056b55ff165390a029e34e86319282db774c78c8de5eaeb07f805903a346e3da078de072eb259e18ca36e3723c32206042ab53005236c450a7378733d3f6ba5927928cd9253e47f941ca623344b2749f31427c9fb1a17c3c968a16ea77fe20a5ae735a4e1f2c17ce9560a90cce6aa77ff842fde78fdfc0c483b2e81a45349ac198fe9d17d4db3c2c30852b7d353ab6771d22adce033b3d6dae3593e249a4acc2324db4d6e5d7b700d09eeb7e40957c174d3c03c5f297c3a061dd1b6ee5e9badbb38c55dd1f65a78303689365ada8101f3accfa82bf23b7f90bf7533257498dc75f05d88d96fd07df86dde92b2e0df4a5cf151123b6d061a9731e60b3c0f78f80f5c81c08590f545e13276c7b6f3f5aafeda6e8d4dfd088c1d4048a8d00e254fab5488cd4eee6f208a384ec485fad34854a8d3b5c046e8420038d42e0cd0177f2a01eed0894993d1aae2c3cb0d6f2fd019224fdc9ead67f261e4ce5189abdba5294c6fb12f4c3308f7cece065757a6eee7ad96bc76bd3dbcc8fcf349edd72916ea5a8944a48186096880a8669366edae84ae2d6c384cbd135f7e8050490315fd5c3627a2e414e6bbda53ce166554652ba618b7384eaad5e3d515bbf30de1aecf4345fabd0ec4aef78d1ef04442e8da7fd036c8de68771043233e7dd3390bffddf00c3325b9c529f4d3d09e10d345d339d9daca8a03777375b0cdbf4a1548db4cb75d088e2a2c1615203f1e7c4cf6da9f77179f9a6338b7ef78f119ba1dab4cd113840835d1b417a21dd688a5925b496f4fc265050668d1fa5b0d91d2e5f56104a602257009155518568bd07d66ddc7909270de0d92876250a721c41bdb6802c9c02f4e2e119c67b397b3d7f3f2fa8df4654d60ec88af62ade1cdacce12fe742ea2ef8c11ce5b93d435a696389b01df5634a69d838effcc1a7294ab901429af63525dc76b0b6974a24c9d205d4058b06c9e119b3a70025ad7f9c05089686d1155b4f4d96c43d1a04aa87c1926a6357a7ee6a2b3a840092b247e8e3ea76f8c39667654ddf8dd99c9ec3dd4ac047d7085223b99d5f8701a18d853a5b5e9e43b537256de9120a600c582923a1d08115ffc4f072186d2ac132d6ea65dd6fbf3da33a22b5df229563640af8571cb099c7420ce997f05f325a2933446b4afd1437291901ef643bac7bf5b18a9961fd27c6a5bfd54b76e25b6bddba3a8cd2085cc69af1a45471fc58e5e6baddaa236eeaf28b3d55176ffde8fb2957c828638d8c33d088102904c48aa5a07fa6d11f654c1419ac18746045c4f16725c4ca583412fe699e96a2a4ff9da55c995f6998be9359d5c0c012c4ff269ffe04a2805a393dcdf51779eb4630c3608a7a0522068f5fa51990fd47bb7988ede0f244effc861efec2ab3691282bc329cc9c68f3a4f36816881c676175c0e2fa0f7fe10c81c1c099f8e9c5bbe51dcde8837a7088c391466d13e10f8cb3cc6e97d8798aca67e173158126e589f43d7c4195ce6166b63942e6d1e91382b1f9757aabae7a2572510f948d2724279bd58f230d140a391de49b7874e806cd97331e7e7b16dd697437ebcab0b9b90dba1a44a98ab84f14232500aaa6c2bfcc2632c119ace2491e15c69a8b4540395407050b19ef4471b4bce37d92c41dcdcf2059b5a4e5933181d0f970493380a14079f9a9d646e47249ea880f912359879c7408b960413325346d633066d41137029864852136395a3fd28faf9903d44a3c92f35180188788dd2252d237ccc3acb4a22371d5a1d8cf7aea3202783a206d72375908a1106ed4246bc3c8396fced8a5b3668cec781b529fe0fa094efb14a72e8adba570d6823e4089e3277272e6fb99d151738d7ba45a827782a183c40436e3745da47c95f82ec9d19d8f99efcfcf3208e3f6ff6fa146a0bf1ffc119e85624231cdb59c1f644d2210eedc15181acf2e6d769725699dc2c71192c7d50f4ecd7cc950a2133b2e6ac8eac885bbca3ead7b2c5bdc60cdfe3c4f41d6a7acee7c996bbf559ed66242da34acfe5461cd0188052dff8deb954b812a687d5cb204dcd44c7dfc1450768933dd16b9269ce32ef0a84ea3eeac12e9d55ed88154ab41d42dc7f144d572aa9312f2a5dd50c83bf0383c2d813ff268999e86707d3044b21b9005f2168d8b1870316b60efb645abcf237f21418cb0b737ac568792bb046764e179af7989d3fc434c02ebb712d2ac7f713f2b2e62cb0dd93f1307183c4ad6fd467bede0f849fbb6ff62dba51091122ec285e3e2e604472c4376d133ebb5ff0b47c512111f7201b687fd019a4427fba28e4a05ea4b771056f2e1eb8e82a9d6b64f3e3c75dceed382520dfc107a2cba7023c0ce6ce9e5083f1f5dd0dc1bbd5d1e7eb1822226eb07f84854877ad0981942d968d322e2003dc88fb419626cda2ef1fbd44a4c9f11cc2188e168e98fb5a5966e833b112f31055c55b4cf135d8fc81b32dc62d9d37c926a2145b359645d31fca6d711ce89186c5311698926127d259fc0770b552bae398dc02157115181ed76bfa607b8675cf46743ce5fee7d3d1564162d853810da75a2b4452aeeecae6fa542d46f9d499f05de7eb51c06628e213397ff3f1fb91ef73654fb628bf125cfaa61ff82561a8a7c2ca3ca958a2b031dd6c54f6a98c2147a659691a19f5b779f4721e12dac9cf4d51c3aec7d5bedf1792bfde49509ca82f612f11e87a77922da310b7c95b12335abb3fbe67032b2203f4b929cbeb2b1fde8a4b478b863ccaed2e0fbc0a312d1387c96bc37e83191fd86954ec1721128f32d988360f34558122c7888e74871541132dbff86e5dd1284278bf2ca73bdeb5ac4960b394e1befa90b068b5e6c67ff429d971fe79d6050987c772dea6f04e1f71ea9a51f33570d86b25c83ae5806df284be486dfbfe94772a8a042d9b1c6c8d843188cddee579067db073fdbc0c1be63045cee6f857505e679a9e78bd8124f2c027621d110b4aaa04e00321552e4cb45e57ffeacfdc596a7899565cc9e52ccd48c6e2e0e0ffacf4ba6c9535af26ebb290703afaf2e255603435f937a7cf9ede537fd81c62d96faf9fb932276c41d48c0e1b334548234088a907b6ea3d97f6120215efb17f51002fd02710aab862f7f0ec07cbc05fb8c668b63f212e087aeddf54fb9805912127deff2a59b7df30223123c1dc0ace1d99d26f003cc9408e98eecaf38e430cf39ba31452b1282c7f5d3484c590952fe143a4713840f5526b7e3a5c9e80b1f078120de4dde28b21877c5005e5fe227c320999befb59b716303afdd4d7bee0ade5b08656d1f5ded9c661b63a7159b1a8c5346d0c1b33a1f630957c7e7757e31939d28082f38593aeded01a47db66b2ac29a21c8b8bff0a9baf5aa4b2f989b8f79481253a97ec383e594021b74298a7816f59e53169efa3efdd18320787a42e0a68f0f313180525b26719f16f634bea29f171374dd8eb3e5019aec4ce55d1e6a6d43675529e106cc3904ddea88249412b2b3b0f52a1ee34a87f1108bc265df3bfa7800ca0b8ef52a94bea7686fe2777f1dafc263ea825cca7593b65dc083f1c74b1b2f1593f936239384a5c24f1772fc91a803f52e157b099c9b5762782c98fcdc4a4afa961b02931366f2a83f9c72b328c6375e0d3b2a7df006bb411db15e36f0cae3818122fd5a3b6e767a1407670ad260159b3f1d133df24063dd8293272f8555b2711c9d7c1aef5c7050a78870abbe6281295281bf6673efcc3cafcbaf63b0e68175dc963a621ee1229feab909cc5cceb2555b30f8ef3f623604e51146cf74963dc1f5270ad7a667d40f82609b2872870ca848586348b54c2a03c3003d525a8b3994eccd3650759b593b9da008cda9a4f265e8882cf33ada9fefdab9da7cb6d3b53dca70fe0e9bf7cd7d0f898f65f289246a9878ba5752d2ef13cd3855a36f773410cd467668936d946d07e741a6b88062b2dffd3e38d44f51ac52dfedf65eded12ac6438df6b0990d72dacaeda25128c4d1dfa67a4ccf341aae3d5544ed16b0bcc8eb9f4449cc8202e612a21b8f4574a3ce6a5419a29775ddbb03d826e6703343b79d7ff5f9ea11330da9e16d008fb356f456cf8c083d883c4f97112782e3954acf3356d0b828cb686099a2cf444e519e3bb57a416bc5fa964313d3aaca83ff575ffab56ad2be3c4141f1d1009bdedd295b492a380fccabd1b6792431bc392ffbb187fb92e682a5049615f8725a5cf88bbcbaaf207691699bef413bb0be7d9c3fbc388021ebbe0d2e396ca68c975354f79f2ea4d2693daa14046c680e51384f4d55ee17883bb6def5d9cac30e6c3d65d9c25eba248297e3fb759a3fbb435f0d75c8df2cffce6e281e41b47b25544f4202975e58541b8c5300c1e0c7976c582e7012bca9ac363941719eb0b2ae21bbc634265b55576375e54b8c4022ffa41ce8af77b2ee9fa7a0d937b8f0540e045f3c3d947264acb28c7b1d52488992e07b963dab9efa1a0caaace003acbe6492f40a285fd46ebef3c0be1f120976dfb6994230f0a43835f2f5b89553d901b3d6ad16f7669f39d8d46b864b45e99465d94c93415786958b1d3db325fe9ffb934a030eafead21476157e5ca80d4d00a0e6590820f1e6f15eb4be7a7f46e08c0941778815ac6b4c0c04a9109524c91998cc5f442a87124ba8db543c14eb9a38214ac3adc88777c871d177145111d09ab8c4e79c846973332e71b145d5e46b972859259edf1d2ca1b195724020f5653c8c2b16c91048606714b99701c2773ee1943c336bd3d6c79afbacd1a6799376d5baac800ce0868225eebee5f26b79e2f1597c16e3e7892c49a3fa6eacedc932e9bc408bc3e5dd6d6440330c28230a1caa4d53883ccaa099621f70e8778b55c6eb0a6d62cfbce9a5043e932692ba00e0064dc66a3a4371105d944658a4522f75c7a1d3212f492ffdbb97919b1efe651f56ae477b46576935b9ff45d6ba8ddf024fd4fa3298953c87fdb098c0575b69588b27c6c515f557878a723cf1e716d79ad4b332dff5c7ac010ebcc60b7fb7e2f0cc1b0e3b3d883b51dc3c9255971a6062ff3c27e154ee82fae08a25bd77e290078188a56e3854d11097d85105d94bf7cef859e2f3dd9a195fbb7563d0b069003919d6906411ec53925ef6390ff2c6dc0ad0b95269bf7a0e685dcb48eeeb4f41006168beefb1df8295f1accebc1a7db3e89992ba851f8e911b75f83450bea8730aa43c0f872e29640e1b2b35c75d90150b2c518aca70d31ef6a9d0f67a07c75fb013c5f70d6f17acc47219c50024d976a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d74cff1759793799afa41a473a01b574"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
