
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <link rel="icon" href="melete-logo.png" type="image/png">
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #997f5b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">

                    <img src="melete-logo.png" alt="Melete" style="display:block; margin:0 auto 30px; max-width:150px;">

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Melete Energy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e89e1db8b3727894efa1839670cbfe91a35777b901e66050864bc7001906a63ff98f422b46ba4f012704914fb81225abbfac9a135a49146a3337ea3c2eea557f39641fe8ca32c28521ccd7e4b988e871382c783b6820f2c746431273166268760113383bd897b6d79613ef5158d6cc2383a9c45f21683fd521a6b5824598647cfe725029e5c954a31af81409e7ca70f884a6f5568968305d5da5871fd0cd49187fc8a8785b7913227d09c4fde5b5bffbbc1638f9ecd2ece369684820f5bacfa28915bb07c9d85b3396bfa85895f51ae6536565a6defe22ecc9191b8b5eb4bc6306ee42b5a068f02dcffa635e5cbe4f357aba666cfef246f4c3d9c350637f421955a6f44e915a6f9f7a80d5e228dd43bb8b5b53fa64b9a4405a32433c8e0802d72b92db2caf976674421befa05430982fe532dee5bdb749b19df1e4ad7ec4ed0b443ace6235d171a8a749873e3d752910cb976914f1d2aa35a557c1bb55b8e06943ff23d0c048dfeeb0fa3234e0e8c50216183beccaa82d4069ccbce406fa0b98ab4203449be97faccad1fbd6e97e6caa30924ecc80ee49a171e52e02468e79dd9fdab7e12344d048d4c83f4de1e34160b8c6a48a9ad8a000adc2d566ccc5de002571885605bedd17b19deaea0216ee44195a26f39c322de66fdcc3d022dd82baf387814070127d83c8a3e7784ec2286af6089294d7957eb713298edf443edb9b843bb35731402d5fb6b8e5c26bdb19bb7de58eaed3cbf550507ca28062aa6ea06ae82be2a06b946803465567ec76e745fae9a4df46acea235adfbcfc5b496cf25e4b7f207075cc99fdcafa989df8d5563402255a48b4b22b79228201d771e97333d700bf2998de53381763b190de492a51214403884c36ac96dc62e73d5b3cc0b3ca5e6c7439af7524a03dbcc9da15f95a47bdb9ed5a7b8786bf68ee56f82b196111533312e96ba8b45367460fa0e4b76139f9272dba92e4b5d5960ab08d4188d52f1dedb409dacf1f283c6501331b619b43c65d357fd56932fe670ac745f939151fbfc53aedc9a77d84276361a12da86ff0808be0f7afa7e3b46e43aacdba049e240e52c4993ed5867085eb8aba8d0a6e75dbf8baff649dc8e92e9183abcc92e13b0e947aeb5ffe7c6bd3be8479647b57dae668b997a564576154c628465b0b4833a5f0d9ff160e5cd1775013fe36180d941c29560d4bd07ffaab796fc90135d7222df2b2ee71c017729ec7c705d988435986654153a137ff9f0055598a17dca94448b169747cf14743c82ca90bd857c82dfb64ba29116a494bbedeb9b8b7cac24b64c6f6ebc8004b93c199c4957227158b7cd6e99f524c4bd6e97b0672b0936ee54073eec68840e949e00d70275008b841772b593c762da0acb00090c875f0a7975fa675a6cfdf17d52801f39c678a3657786cdfe8e976a72dc47b5e7551979695becdbf78491b8f481997cf777a63f58358b1ac353bb13026e54b781d4ed9f5a40c5fa8593cc93d1c3ccddddf4875f91c6927bf45994faa1517c27d176f30698c0dc61ac25f95d81150ca27e76598f1b4a3ae951cdb914507d40ceb7baf883ea4534259d847c142fabe73d7a2f5fbfecd0da6f73cc5eccc48d947d01c874dd62090aed6437a135993778d555c7c463761d76f3cf051a1a5fcf31f2662bc0059c16872a20b64f7d4b2d4261fbf0bb39c35e5b110f8cf56f5c9c3a40358e229e0f91dfa695435d4ce0a82b6e62e56938a06c35e6fb0f8d652fc8e8d5e20e5977ec1ab62dd97e0ec68d707cae7d30fbf14cf7dc10eded62e0249da0e7dadf31ec0b1d46c8d1353dd5b5d18647d91c0fcf77a8b9b65db1b803b84c5e96d1d454775eca308448559e3790f6365efb7487b0cca5aefc746ab4d59ff50473fe178400d1cc0f8f0d541ae0af81d0d10b23410c646ff67f89a2176d755b0d4d0cbc13b6a2a47060e1071bd727bb524ebd7cb9de61fde3480141daa2f84eff2c0faf8ab6bd9a08a7d385747e60084df0c1dcfb433cefe515b7bd205f82b22cad987a886053e3c7971125b865cd8924bc6904cbbb33bd6b05103eb2136314cb6a6a583e1b9aa419391da7ade6165afe6891e74ae443cfe5c3b72bf02a4875674ce51f7f95c1bc7749d830c9e58d049882c86a4a1a6664183200a8f210efa363aaa7ff429e8b2b04d8886b1509f058bb57b2142afb1fe8c5cd7bbc39e99c0969deb9245a772918e1e758f4d472dbbc35113b3a0e693441b00e1cdfac16932cfda91630979f71f392ce852f34b1839c03727d256b550421af34676e3cd139e0998ab49e2ac1481466c4b1b5686840f1e0f5ac0bf48041e1cc5fbbd6582a0b5dcee96c15f8cc524413fa7a6292d4abb751442ba76a850d78f10092d607b3663bf0805021c60a9f0d0df65086a5069d7a343aa164e9f6119875964728236bc8c046b3d9878a3ff36a7d77d133124f5aec49e8a8adf474094a754f22f1a78a6c2c3aea541ae13fdbcc5964dd6aa98b7bd242cd62a1a5eb08aad153997633073b8b33b6e80d659576bf84983822bfdf909ba2d436124ca49519331040fa26de571063461f247c397a222678def5664288235d8270de9afeb5472155a2db92f3b5f5608d9b7977dfee3576a00e2daf731e09f6e80cd913b2fb52493b9f52f0e14c557893e5ca669e16edc4b3dd566cbc55d916c91b1116077f048ce7e5e6eedd6a8865b0896f91ba485ca8144727e7cc2245addc284b6a456d4892d8e8d0e9f77e6e9272f31bb9186e41a739ab86e0d1099429fda60242d6e6931c8c3dcf35f28a77a34d6cc5009d9b657adaa2bc3240632213ba17475e2a534926638eb5cc9b5ac07443673777678d1cdc77d180c27a2dcff1ec29b2e29dca4a1a58d3ca393f3a946eebf9848e56f831e246d6c0428309a3fbeebed390e6fbdfc961231aa54e145e6642c4487d73de3d406bac95305e16bc68c5cc4919fe6d0121b89842b771fbf155347fbe237f90bf38f13400ab5bb689b4b5a8b294a2eab0fb26dc78bc193a8a3746db096c859be9a0476ff823ba40fdbf0886870a2205d3c307d96c6c34d1bec11e9236b0ba406c5fd922c45aa2dae3e2d7abca73b6c63c932cbcebe89666072492e3d9df672ff939fd9c01a347403d7688fd6fd1980dc4392e3d7c60864e39aac9019a862fdf9094fe302b7484e192bf2ca9d0bb8999fc796c209da6c36408b9491a805cf8600242d3cf76a16035c49065235bf2bac9310f272cd5213e28655b8c3e59656a7d7f0b047c8d09deaeeaaf1e396837abc456da8e1353a5d2c24e5a6bda4d7fd4b34b354c0fb8d9993163bb2817164a9551158464d320417a5bc63bda49a7b47033bd1b318be5d953b3b847c95f95ea932be6d8abd9a6531d7860afdf433fbaeed3e17819941062d674569e8f71cf85bd5633812cf8fe56c065f22ab662c29bd7b81d0df7c9dd9d400568366739eed7004d6118896ab8e51c0973f22755b13d13cc96126747b7f8d6e064fca0419f6e5ae7293633e3f0ec19d846e52b047c904d325d70415565b525d4cd11bf57c0504d73323c1017aad8cac426e00a4f5933d71194562052127dab9dc706d71f5b57a3a876ce1bfa38baeb963ae74dba301d4e05261faa6adbb3a5c34fe6b3f327985d02fdcf0568e5d2b385b871f004250d16c03139c01f3fc4a3b17a76e06a1de7dacf0eb2bdfe15ce0e7344fb573a81e6c2c077e46034f210738b7762689d76717fed23d906e127e97ff0065fbfddefdeb685ae7ccacd5f4615101576405e00d37b970679365111fabe2c1bbbb7c6756da52914dc41c9897bdf5fa2348c6c04c47efc7b9938424c59db78d0c1bfdfca5c75e6ed0e45782239e9b9fbda7b128f98f9d9cdc3b0729303b0a077dd739cd207954a9e4323493ceb2da214f18421433615c7d2061206e8a5cf44b213efa3eaae5690ca7ffbe316c0da60714f30eb32208181a927a5e313f1d7e93769d4b876ce876309e4338d542593e203b9a6a397bb8f6751a4b20c3f5b33573849de7dc41437b85b3ff01e68fe3fab3466f4c2a37fcfae7baf6187dee75eda7f9af9dee24d39e5966da828fc99268992ec8722f5fecf39e9c1fc1b6855a240768961fd02c319396fcca1819ff0a241ce17c28efb3e1bc185ffb707b1058bdf3a225e7368e5e71e41121cd0076a605c0d8167027e81093af7c8915bdf14872125a2253f81e4816ece67082ec009630d5091f7a3b2427711e5bc05460632d134541f4e027709a71fc9031817ae1cc3872d42db886613966569bfaa17b16e5330d5f92d6edc9a7f21150e9776f6293204e19eda5057a13f7480b73ef1e38e18d59ca0ece14872a980854f6211a8bae0187f7fb166940cf3098719dd0a5a42f2fe9911f2878139e309d62b42c6739fa3ba7aae0cbee82c966bdfdc92192116d2085c911b41bca7779c58ae299609cb7e60c7491e28f6a8703adae3aee7e74d3450157c791eb1174cd6314680cd71b2ea8e2e06c1daf572c7ab9b034493ad55c176006ee16f86a4d42837bc0a0499b3c9e706b962f689557468a228bc8e6301ee734557e5dc567547b8ab1da2a5f885d0793a96454673ac957231f27e91e5684febec65e38f04acaba838a332adb40214f939e2aa9a88c871535bb15ce103d2c366f1008bc2069d2259b4e3f80b69e47b88b88febbf3cf19fd3bcfb64ee3f5cc6ac719bd7c06b4625ce325a8ff0ec4eda08fe970a9753198ce156ceaaff56305643d8c82bdfcc5320a5fc617a0e2b01ba80766c671426b8ed1de902f2c7acc4112cdb4c623ff9a7cce7880219f89e6b5b3c7e57d94a717fe5965046e424e67f8720bda35b4a06f82de2b40dd966de0e628e642fdc23bb0f9dd68c64dd58d97e6f11c4a549cdad9e5da42463524fb721c3bf268553c24152789d8aa823c11730ec175ed38600237c27cd24d62a06ad39cad58f0a9a779d805c054f29a2f2249ab1ca4c638a2501f0c2966b8f36112d3597859d794cc916ed7ac3b3d77c1628a627ca404268a2f37a01835ddb0b05a81146c8aac8e6d90eae729bc2625af597eb0645990008dc024a620ee0f194f44dbe730fc332d213b0d4fd530d7ce71ccce26576d4baa12fd376c320e5c7f1f498d64f960ccf0927e8af1fdedf69f8877c1b119550f4c84a7c9dd306955fba1dcd1201bb9feb3b0ea2ffa34a6edad5a5254f358d37b5c599efc2b3fd18d7d852133fa2cbcd53f9e16ab54db72ccf7f9b75de6cb353bfab7208ed2b09e3429b0b2335c3d6027854b0ebc1f99b7d85882d1da98cc938360a51996596f6b9e5686075b7556aa2d14dcae36701b204dc6f98e96ad2c32d5c8c5aaae4aae886d7058c599393137e1891e4c328d0ad4e4e008c1e70052b7afedf4dc5a4422dccea8db39ec6a65180aa46851fb3da76a4d0f01e77e0c1cebe3ccaa6d7fad7e0a1b0d08239a9c954b24a4baebd9b7cdbb02071b3523db38779cd26719a8b2bebddbb4492f21affe1591b2d9fa6ced55457e8c696317106d38034a5dc944b7e681c2c4f01346ba051cefadcc2b8438be2ca25898e288bee402fca8d5d5c601e26273a07479788ca06fb0da0801fe084debfa8252a2c20781755535d94ff281565ae32d5dd04856047acf9420b4e9f335c5686e3c3d8baf806717a9d87467b7177d3b60d3558812195869c24bc03bbac79328aae47712082d49fd009f82507081b4b6c0bc317bb1fa5df714edbcae8ee7819068a676e94bf22ac2e598bc5daa8cf42eb233ed8f7b6f5896a86cfa523ae962e532dd372b3bfc9554350f3a9e03cb9b9ed6cc84b4d47fb235fe91f456ad5a130615134dd6d7fa766fed1364d8d0a3a044c12ee6ed2136daa95783f93a5675b116977242c07c53256b0c9feb6dc2e0fca33a260aed264c9e52d8ba89377e7a1fd292a85789e2255d427cd66ab2d17e31d8e8074ab182c5ddd767a2d8fdea0f1fdcefa3c866a526632a0288ef6192ede584509d494801d2f12a46549d2c6e90e1b281b98eb06217eb38a78fc2612f761c1cec7aadb0b3d475413a765bd47338193cd239b56a6a32e22066c0f685b050e86618db81339e8fc98a8c8982fdbd11aeaf6f45ede7e61ac622e446749aac9e4bb875084c881d06988554589c258467d6f06a560140298515f91055a08d12dd4f7c64d9036b5f6247549ece2bfb6d50b156ec30c1e54e31f3ab1ce8989194b74c22fa14d7bae33f0f2a2382033c372ba733425818634b43ee79217563775a37a8b8355cc23497966e894a339274b3887f79c042c02f83406a3dc3178293619f24eaeb62b998a6e611c5f8d01508083a6b201f68ca610c2a872e65155abc87ee04eca425c80e244c152465c23628cf7efd97d9054fc028ba6edfa5b28c589e769ecfdbeb36b6e2dd819967d3694b06a26f29651f8c33e9078b29295e5688ef6b0b1bf05d51bfae59b59632d04546053abd9f488adb48a677f05d0ac7bbb148eb2608573181eea038ac9c06185f78bc8fa51f40ab11460001e4c45be18b81ef006217fb344635f7a2c846f7276cca7f5da13aec9f78670eeacc3644676916d1eb31536d6da4952444d1dd964097031272307b1d3c4d175d9dc20d3d3f7435b3dd5a82c35b6b2978d14bd61274fb74817cee3f6a1e4784ca313f428c91ce50bc84384c04f32d796023f5915f2524fab45ae200b635fa851704c2eed24515d67232f93ddc915ebdc694f25bdac5ef285e493a6858647a40c34d59f325cf647e66e166502e26c6d49b6e9e5b6675bfebbf82ea7215a9c6eca2739b84bc4d9b2ba5e513b1cc5ed12a400887d8a86770485a358f0199b9c32f1e43085c4b3d97541c6db5660b7197c219c6df038ccd16393164c5ad895650e6796e653694698a6aeca1628d68433c6216bc950f1f5db3ad06b0c374868342abfe233d0f85e7dec188bfe3355a42079e8b8f284b358e21bfdd0eec2e7fde48f7c56f965564321962f0034c6099a7531a8aa1fe58881361d27ceb67230cbb9e3f683bedabc7505096190fbf0f8174564d9dc8b799c6b04cdba4d427f42fad87f57c601ada52ea9d8705be3e36414ff05d0e4bff36e7c733b7e31c6b056f15a64b310116b32194e256ce19b71521548323643ca8e1552cc320760f195b2533b5a427037d631e4d8d37a71b81ebf24c1d69865efededc2abaf3fe9cb2a50647668ba4b242437ae47d50c7ba21117c01b9e7b9ffe37c851b22f522e4f5a3b54fb95bd0858bdc1969c1aa5a83ee57662c137de58688c918556cc8e6331eea9d49920b7d7f1f117ea4023ec1e3ba6b515b2c5c15b725ba0d83c9a648098ef1ad1233d7de42371c4dd090bfdf77e95cd5d6048967a658d05352a78c665a2b0ddee176b0b5f0fcd4ceed2d381b82d4422ddc179d0cbc411b7e560a327c22092599539a214c4246aab3dbfdb0bf2637fe296b327d632b57936e35309991e1d03fc028b634395d7cbb6e98bd5d00370d4d5cae6bb18ceff16c39632c7f92ebf1a2eb03333a674c88a3eb60ac69a87a837d22c6c6fb8e3878d70a8b1270aa22911cb98f3c2096008514d64de20f3322091754415cc6ee8c6790f35145cda01db815babb5690327323e7225ac56c55bd692a6f06b3885ef9eef5443136e6ea3b32c4a1cd856f756be858b8e8b32a17c380bb4d65d39b1de444756bf133b2449b863abf9f657b34754303802a572717d1288348c1d32f7555e82355dc705a2e291895ae70dd9357fe30951a6729cd1326e993d0a5609471b95f05274add6e44b227664fd2bd1342a205f1f46b359ce33c60b672bfba34b9310ace45b0e2f146c66cfc18b105ae7e2e32df4368cab09eae70f828dfd51b96c5469ce86f85e0a3ad8d1738d1422afbb234973387a21b28b145ad679129036fe9db6ae5c863eac86bb9a7df27506fa9add983738a2803f02a0a8e500e378de5bcd5a587f6cef988a1d4f44680bcb31867aa437c922d31ea5b30b642027b0403a0093681604148d70bc7366e5d1cf8f50579d163d2e134ed3307a857f465b021df6a5cd6240fcd59946b80f500781127bd7394b5ae29db0c4a7060bc7c32f0de5768bbd3e10433754648e7e672747e2e999220b3b1e9b7302f902a942bc845dd482fd922a4024153eba7ecf68c8f34fe373f49aa76646e7976c840a4a608b706249927f85981f04137afb095fc886bffaf6b9a2b84422d338207e2c79f6184bfa4f4a978623fab0fcbc5ae0930164b50aa9391c0554a3fc5f2e84edbaedaa8d3414b9cd2dd14a8b9df9df7c3cd1d3d94e16d208dfd13fdd12bd304a6a62bcc25f71910d33b8cde8f1e23bd11c25f1da4d6fd09f6530d74d8125ec5c99ad4b0eee83605df81faf12dbc63df76faa2921b3ec9983e59cd01b80a6375cd6ed789c88a61100fcb035bafae569f66ce030917c52d63ec2d2652f7e3cd6fc7dd2bfe5cd5ce11c0ca78336371f1424e64f6f8e733458b139444cdc61290a8ee9b68cc26754dadd3d18168f2992675e0102aa398da50b6d5a5246f497467a63f50cfd4b331a6a0f313d90bb47b646655034f2c029a54d4b5b0a0141801923bfc27958b990d595762c8cdd48580081c4ea2bc63a94c9cf3f222765cbf7ac306099d41760e95c9970d0a13139a27e5bc657fb4abc36090b90ac446e5c83e907f2266f73a046b1a1fc7a6f5661f5a5b1359a4c21d32d424f317cb1bc0e1079e408c18372a8efd29a7116640427eeab7971fde8050b2ba5ecc87ecf9fc710f9f5e9c406725ae65f75b2599705860387654e5060797a30e3159e34b56ed812321b2b754c1f2becae6b728a9c3d8deb8e3eb788232fbd11bed5afd19ea00b4e9585a07864cf03348f7ee9e0be67284ad0fe52a54c370a28caf6690f2af8350ef228d742efd2f7244495322c6fc0a0e34270663c3f2703edacba154580069780ce1ce21c28317a9a45a1dbec5690540eb89df5752f130e95d0674800028032bac9acfb81fbf9a17b01449fdcfbb15aa95d51efed727f9773c10cadbc546848e1dccc7e7a39e73b54801e10ce5b0f9c58e232f634aabfe27b73ae1fac32e93d11a1bd5d706d0d42d7f685e051372a45f77779b11d029bea436c82779da88a8ab16f46b16d8b5fd53a552beda915bc5d3f4d476921410f42a12cf3df1ccd939f8caa3d5683922a55b454cc0d3fdda6c8c6096e9a92683185f58726def2588c749407227b5a0fce058e80be7380f1a6ad3311734418f9f6f02d9b6290c06f924e435db159e51d1b5b2529fb6f5d12421049739fb8837f2a6d8386801cc31dbea12b611de79eb3983fb62ffdc8cafa37fe69114f6c2de3904de4256b8bff545e289bd620db97b3af4d2ca9339543cfca0f7f1fade49526a1ff1a28279499ec8f096294b751a5c173f5d21a0ce7aebfc5300cb4dbcf0d7440145de27de8312066e10e1d4b139aaa51a66c4e99031e00cf8a1e4e5b5a835a39cfa62e6d77fe73f4d26649fb4e93603ba91b6f316371d7d1d8a2cb43081f0284342be2b4852f45125628bd229baf1bfc3742239b236a3dddaac7a34fc80a558012008e8412da592d835025aacd68b5e30dd44bfc3f48ddaa0d85722baa28e20753799c287c929e5488bb8d31457aca656795a2c71b1f6c28d50e32eba6be9374e8ae1de5c6d8cb571f2217f7491285719f6b157f1d6c4d0ca529570daf56fb96707be7d3ed8b5021e30c394f40665b02aa8acc579e42cbcfc7bf4b81b7b814463c53a70072ce3ac6ef09dcffd619de15ba72766891df31d36ef63e65248eb8a3191aec0dce1c2b6644d850e21fe8f0a89fe7ebae74c3737ceb69778570a1f144de71e6ddfc65cde3266fa7f22b210525ee21ad1ce8b37e7a698fee6529bfb4530bf4e5949ee277cdabe2eae93ac33dcbed4e1ba08fe759b3d4d4f088f7797601d28406b136275b326874ad2ac3022898a229253b927b9a798c4d5bc67d679c10e808ad9c7b8bd41e430b8bfc661a1723fd10a895bbf4561eabe85cd232ae99f99854e9d2b598e524264d75e88fc2993dabe18a6906437912d4621d41e84ceb770a065badc96a35fb1c2f1fb4d6e16b3efd55aeb3cb0150e2f0c45cb31778a26c5bd6f1c1e393444cd57d662d878b98d5cc52f9d49d4d769cd37ad2c0f11c257a3a08f8c994b0930cd0984b34fd14fde64b6a70e0a0605712b7f2aedd1c4fc25d19e568fd4913ea7955d6331455a0c2666465b5ff1e60d9eb468b1ca5324fd3dcf5e6277cc0537c309532881271a12351bcf9728877d84286769ee00315178338a5041d3249b6632e3834a6af31db5e7b870081d1da3275bb15335c117d9a623157dd6382887bfba85a4c780f3e210b5acc15f20a324bb4331b4703d395983f3b9916a04ef2278ad14669e1b77e2b4dabb4b03f663948206a2edc1ea4addb028a515090805ec5a8318abbe3f1812c5f6fa2fdff82de23d3f1c5bfbf207992be027d8b2f02753d5112b8c19418609f0dff2e09d23e25d44f764ed6c1a2d34ce60eff20050366dc969fc65b6bc79ff6016478eede2506af3f17aec1022770f4a5259283ff2682ae4e1181c7a2b6b462fd32b410b4008f1a97acc17","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"601112292d97aba8f62e6c595878fae6"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
