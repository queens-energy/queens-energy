
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #997f5b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9715ce008e5cbb911605842b33ad88ef8a3b6a61b716509e3f772b189860cd9c028c21528155a5630e219dd69496a5f5938c0442631db8a45020cc8b1f8560124bc9c85744d4d0dce37da96690074f5842aefa154668cecdc0772c4074545b3d943794162b7ebf3e6090cd97071c91f069587567794038f59eae511746f41b08ac6ec8707f67bd1c5a37110b49fb087e1fa66eb819fe810c433c62ec2495c2b9b0de8618442f33c51909e5e2a42589fe28e8c16463f082da3c4231e19890e3ba4b8829dc0259073e3dfd176761948859089ce96cefbd8dc9d0587cf8260a1c689a0deaf77e07b1f79d0ed0659ecaa241af6020585cb08e41eedd6de4c6577960f80fe07dd2bbd4923a4183a25328e0c9b1bc51beb09f0d635358dbed4ee6afa15b7446c72ad7c6e5475db0e735193ea8df9713bcdf1e42de931902e4dd6cafa2cb3072c10f7c201ff59cb74ae07d4ee11cdf011d3f6bb3f8ba430d2fd7b06ea8898d0f8912779c50e27d1e34533f6f044be395fca34d79fc795372f2dd28d270510ce1f86cd9eff37b1beee79e5d3290b2bc9ab8f6f7ddc41f3961195ef24fa90e7d69efffab0ada8c0e5e52c42aea9b4b27498a7edb89dbb5d23a765da50f9c99045db085da19b0c4128057295c8c582f18c89cce268c36ef5642032395941c6d081429b384b854fbf9346f6a0cb69372a1bc09364f7acd20f10100b83d5e1093ab1010ee44421490e0aa2b2ccedadcf36891e0b0f5f34d0a9d40795c5afa4f0d9e2d199ee975e752aa7e58a6820f24f78345006f3656345c88254ac0020d7a027b469c755dc31c876ac4bc1b00a1f1ebb56842ce6ec776f6554fb09f523157df4689d1314394c6720e8ef834ee2af416fc7b24829db8c883d23d150203dd3267588e5aae818ff5e98533ec969aab64e4aabfd85d544d05ff55b27cd4831095d3746c339a6c66fb519f1967fa1a021136c58c25f87a02fe6ae3c517850072a3c364ef2168dedbf130fac5ad971837dc87fd2900edf4b5006f8b7b3066e8fa55f8a344e74756a32a94ab0ac2e001dd15772408799ea7011e7a6cf7377c3f20f40875f0ceb788366e60370f09878a3a92fcf7d273bcb390358113a4050a8ff0b8abf17910f8f43071489be085fd911131b9d0e2364007b2eee713eb26191882afea17a44d81179adb4ae3b95a38c2b33d0d9031ee1c4602d244a987bf800d49299094641db351056f1e9e9d8186acd1d0c5037dd67f53f128164bc18dca5d71f2b4cb347ff6876dd0d7c3787938de912a8aeb9d168a36ebd2324dd0e491ea9fdf8271d2fdb124d343d51df40a8ab1017b17eb14808af9759e70d595a0355e95e34eafe385fab10d4690f4f96982916b628bacf7d95114db8192e5a5e4209ce5b1a8986f0fc8ce3a8183e51193fa2b6e27b22dcbbdadc49303525aeb48877c07d2bb4b4fce8b931902aaa58c0fec9943541a9146ae7c7fef3f2c6727bbba026b3d6b115ddc6182b461b06a3e48d36d33e0920f2445df377cac10f218b3dbf842170784e87cee1938e9fdfc500c6f7e25c0cbeaa90f3b4fe510429695a1d943d3d7dc8a692c29f9e3e58292beb57b731cff2c5c14263c69173440b3a4b46bb3d830277ee6c243c2d1ce9af26b876da9cea58669c38081467eea8d4e8e6b1f2ecd32bae7f42bb5edd4087f60080ea6f2fd392c713e782e6613de39003de08a1bc029ee07eda9866b96080d67c48b13d30d973fc925b721608cd16a51dac1c9b605f19bdc02a64239f5f8fcf8eb6ccf98fa650daad290b5e4d36c69c275abf2931ffa06e4ea38968caafc57903274a38469509aee63e26b6b49ddda2e1ef7794779d576b2cd94edb4848f3ef45e6f8cadc1f1b33bceba1fd2fce8d8ee0e6745367594eb0ec9b5739f1a254be9cb3b047b59437fab8375aaa63ef386f8d2cd30a76e83dc15e0d085fce900ba0a17aecbe53fc27c30d193bac51f6cdc0b853c0ce8c75c35241c33966b031b3dd5c189eb4db1b412e15bb2532328f31585028b17fd3d8f7fd743ff154f14c4da03368ebf96752c041a6bc55a76925bc72e628708050b57e000b125871764d1a839e05f3a984a9b41397da9cf0306d34ecf5fc7470b7b65b3797598b66421d6ef9d876c871ce4eb5f2b4a557748b4465d7d63ae9501ced41d7b5ce49018cf09c8fcaffe1ad2185f664a192847fa6d1a7a90ba5a67e5392cafb0d95f216805178348795629a741f8c7b5072f13ce1d70fceca3257f43d98fa9e067f4f93951c9a02c0609aafecd6ac6c111b7617427268ead1fe6759510f5b88c64e1c24c242e19e16f061aa0f035938b4b7ce66a6d8ce5ada6384c1f2e54d9ae4e2cd0b635b35a46d29c1a2bdaac0e4b4d590d04380d2554fc324399a411890dbfdb623841170c734cbefa7f1a07bede0d8e9ab8672053802ca541c0ae793eed8fa038c1ed1b9e40766e241870f2990fec299d7769853c9d39e9496233523434c06cd1f2d44d8148ef00be952154bfc7c72e8c6d64002ba608bc66cbc392dc691bb18be74973150840e80fb0403790305dd8a2a582c915fecba9e078c20fa614c303637af2c2b99ae121264d51a6cea7064a87bb83ce5adb872487d2d93ddcdc6d99a18f888ef3d6208636d6e2beaf6d6a8924ab2437bb8f37e83084e6b2ca4500084bf84b7061755858b6bf4f99cd5d151cb6f784893dc04f370485ee5dd4ee82df16b27b746874207e8f0fbffd2500d8c4b871ae5cae03de465e36b101422c135b5a35f67b3e34e204121705d596782a11463eec14d4562f79ad7f42ec42df9858629eb4d809c0549fc1da98ee676da9e31ca46dd85cf6fdbd9e82794acd206c49911f335d7df2cd048a4a44ee31dd740020ce0bf0b2a42e80d92cb542ebd811d9fd401985edab87472510cb0b77eebc2e63a9134d88609d0221f07f0ef408eff5270c0a8d23f50ebf4663feb5dc485f79f83c84ac8d76f7450c94d6dc7628dfb2ead55804a91904447d726fa3485e079be838bbe59f7a8b49fb0ad75965ab6ea2fc6fab29c2260afbefd9bd14a97960631d1ecd98a60cbfcd57a905880379e43a1535a443092c3ebbe76dbd55950f4a08b7f7f384722f5f9f0a7a306d88ea549ee2d321528c2fa720537d8012eeb6a516c8510ab49cc81b9887456ecb62512f9357574940f13e080cda18929924f9cdb153cfc45fc931576169c74889b0a71c38ec00b80c28907a7220ed491d1e09d36e04a24e1b8cae78e87430bdfae1bb5cb80a18be0a55ffb6a8ab298905e195755e2e3018ad0b16d44f2ac2d5bc9dca31d5743c738a56e38036be7a1442b56b10eee2300783c2718bf06dd4a88847825201be7ddab2c4439ce17aab5b8c037060afdd7b0780cfc4171a459a1be5c517c9fb95f0d36a599640490c8938853f3a4c5348ecb2b68991d3adcb1d612103c48961d9464a25ddc7329e208985798f6020b5b3c71bfb75ac2dbb4d606f35769079c7b34e00dfd9e70217f4b19f641e40a641fd9b07264468e1a2e6a899aff6bd0827c7025b176722ad7718e012daa0415ed276149cd781e100b2027b7d456aea292518c14df3560978d0aded45e2c7e80012839cb30438ee3e999f88c861545d91ac09fa73ac5637579e6b56d7242198fcaa7d18ed216647af10ce52e31c9e821d162fc101948bd5a02cfcb84a3a92840b9bc82d62ccb3bc29570b348d795e6daab9677d261a797bb31ba730ed278684e6cc80420c92b624abff03ab6ccd8660cdf7e171684cd56d2e6ebaf77311f0ffcc940a0e864e8eded70f9bcce825dce7fb06d2ef0193791d9d6c9f9c8a24dee4c0aeb1f3b107f73ea2244a326dd3ba8147204b261794c4fec3fe0a8539bb2f3cc8af7c82d7a031dfc46f0a1cd4ad57d025ac342f173c1c0ab03c2b6da5cece009dabb20e970b886936c507a93a6b9ed538a3524f04d6c926ac20d6675a666b8359f2d68dc5258d41793f28c943ef39598394bac2a40b8c467d65ca57f703df7d5f97ea8559b7909ade59a73f7a2dd971ebfca8c0bb3e773d3b8973d7e1edeeff5f53a06e967ab8cde23d0f3af04ec6f3e7c9515ca7f89bfcb6c4e80d6009e1d7ab1adc13b033dc52a8b324603308c2bf7d17511b60b8a982623e88265121aff5f93ed9a1e1b1b487ee5d0ebf837e1c2a7eb18035962c25e4b969b82882b71682065a1476b96e531f5b893d93ba9c6d6cc31fdfc8ff33bda17541a19255f53e7dd8cfa5a27bde265f1ca29b4d9e9da3bed46cea78ba3593cc7b36b2f30e3f44f3aa990c4068785620685b88b009dddf5d86d9bbbaf1e410d1f6e194d50bc0c5420cb75a5e396349af00415f29e2763fbce20f379a97c414ef27e43bdb57b0b646ab8faf3dc5320cb78ce4099c8fed282da337aa97d905804e2f3191ac2cd0bf7467916091f94a760ddc280b85dec66775475451dc936264775123a707b239eb794701adc90faceb26f30d9e804a9ee268c703964279b2283cc3db5d57aa48bf09f4be2150f16e856b623148d3a3b3e11679d32bce031b39c14c3071bcf0c0bf916ca9999d8258ea03b6eae57c5a224dceacc2726dc0d7d1e231773e358740d513f8995e99d2f1b0903a39fc11f060a7d3a2a591973267f5be00a39e74cce8a4dbb136b41144236593927e7686f846665162809b3c4e795bc5fae982484a28f988089d647590d23d7726d58911256c43e31b5b4aec175ccf06d3e197f20d7b75d50dc8f0f1c45bc4690eefd47a99eabbb106bdd96dbacad7eff056545f0f18d0321aafad2035283191b4078562774812fab682d0cbc3dc06601eaf0018e2b32e0ba70911b938253e8f3c7939438513899e31e7028d5e864c2a9e368e1e136082df665b7d08e5062a9e20bef8f2913c5c67a6e877209f04f5e4e036b0eef5c0cdf8f2f7a4f7b5a4d6fa523be9090ed8a241d0c37c5425f59084350588e21f22c84aa02392f1403fd950e87505023f52d85b25907f5dac1ca54fe06a28f78f69dc8b4f157912c4d055ae340c8cd43439a26b37e0e47df85de15c02cf913f49b60ce109f37713a95dc1a141a6d4413d2d9423e3842e81a7f44bd6aae19414d103a37c5070bbb8c963ddac7ec76ab44fab47a37906cd1e28f5ce49455295ecb9df136eb4c04637b87ab0c47bc4949cc32f294cc605d79c065b5eb6854f9d23941131c9c7765e89721ac90fe7dcf987cddd32e55eeca9c9ab29490672c593251b853ce64aafa139e0e607d5c7315c0cbb37b81024768cd79d3ef389e72f044671f1d433513d19641cb9cb9139eba692e6257268bcf10dea50d310999c31b68141c8165086c9ef4e5b05698404209a00ccdc03071bbc4624be00c7f5cf06d51f087524a260185fabd776c2d5b6eb61ab1d8abad5242f589c11cd4a00a1a8ab7f7ea6d775235569b464fbab4d18914964bdc5b0771557584b39b1dbb283ce39e0c7110e2920d8821e7ca29958e85a110ac0f743e78905d1b6dbe8f131db03a04f739e5e4183c684e78213f868340197ae460780773bb4a8d85e4f95430e1ca9a1df7561ac9d1a4a2b3b4015d9c671c251c5a14b90f4e9665bf7ba55e439a3afa9185336ac54567edf9c5d677af08a3bf73c904506aa885b3b7b35cf40c6ad78178a4c26ef5afc921b6479b8b42c252414c281432d70b93199994f5d60115aef5978fe0ee9d3b629f629b6c54e9bd7cf3af1f0f871f071033cfafb4ee6b4fe93b155ae933d2b2f95c12a88f1c07963106a2a158580bf8d9c03f37d3b910be0ba49f0af15683402c660c96516a93563baaae75233e60f32953344810a9f4e3776256a791d97f4220c1555ac74b221e981357916f3d3a3350db0275b577bbbc69d40e5d08a53bf535f83312e37041cbcdb6fbc54b85744c9ce72c3d09494572be8fc191c17d58d4ce3058f1bb92375337de798e236fd98bc69ffc21bda8d5bcfff46d749858eff90ea757fc6622a3cb18979a6aba86c7492a6b34e74dbfe7f26fce70e446ff6afa3910a99bdea76b5c18088576b7961eed6da0a4c2932f9f31e504c1682924b4bde2c8ca0f1a982d406285acd4702003c81d66425a504572eb6ba838a9043a672a2a5d34a6c2152ea30877e6a30e9846b7f396aa4c345edd72ac716b7d33305f8f057dd5597d15e3a62aa55526d99063442461bfeca243f6df26876eb74d43941949c6da2c9479a64de357057e56410bda380a7e16ccdabfc246e054aa80d317b1700927db7bc9393cdb929a31de7e4b1dcb9d80dd009410738249225afbdd1e88eb2fa47d1da30b80a052f4bb03f3f16b1810f298299ae92da0a3f9109ff3c3b03d2abb52446a25290dcf415d4492d4199f6193799f6a7a5f9ef549c28f263e6cd19b1c32f8cb6bd5f62ec690060e21661e66eb6026695df3448df49f3244385beb569e4f73962644c8c8658ce848a191452246a9f5539b52aa31b94c30a1f22c0f1d5c8a818cc564575fb6b02ea9f16de8a0aa1409d4b28af021d51a2c28f6688f3424fade180dd19bfe0227dad3141039154ab1f3d29018af315c05e3f5f63698dffa6b81908e59f3608ff1ea2806410eb11cfa758df5b55b08447014a7905c74b7355a47d1dc0aa3f9e23d1905dc8c9bdd4edf6dd0703e57bb726c01d703cbb56489de026cf4913dae15b3c15bcd3426f01c6b4f33aea1655b756a26fabf5529bf7ac31c521faee8abc63d371ba80aee04eefd044219cda654f0560989aaf4f8948547fdd0ef5f26654ef2d018888c5a4c13b246e6cd00ed76aae7f245a2b29ceac42c42f85ff72745fbaeb9ad438f118391b5664df9654c05f96814d2992235789b198425baa13d8956a766e67cfe61daa557663957b0f339e9383a2084a7288d49cc85a4606e2537112b1c29d531bf81176c058e95e30919f4d00eb9840941cbe84fa5547e60cfc06f2f40e5f4a35e2913f61a073d3de48354e5b75ffd20aa1d290c7ec8d495b393978a94e4036a213aa3b4731a955c18008f60b7b65cccc78ddf787c159026287d247da6cd502dbd136552a2fe3faf4ac1ccc2b5b12ceb7ad857b6c52f99df6b6c9b95fed0676d421f1d562bca82f64c4a988f9cfc79e95a9c6cffe52a3b924db7c19d2252aaf053fe419bac69ecfde64c468be6caa5aa3a0b1e3dce0d4bcd0e6a60951cfacee0c77192513d6d79d004337042f392efdfd9a64f3e6e65f67f4244e649cce41013db38f2feb24afdebf1963ef73608ec46fd73fff3b11728b072ccf2c8f884e7d4d30c58d93f4e8c15a0bcaedcb39492e2d02268a1078292cc4cc2c701a34b08d797a25651a2cc0f488c3c939e3210e1cd602ff504cfdf871f8e369c1856dee6035ce0cb4d04239fd815634c29a8c6a2beab4f26890516f37891554d5b36ae94fee5759be2d983a0a6a11c2ed2701a247f4c7e751be23a0802212e70dc934769e9315cbc4ecd79e923ce1f5402d471169a84ae6260ec0f5dab625e2d48a036ddbe4044d50470fc065119e2fb3771ed100893d014f62224f999c74489ea4910d921ad061c9893d4f332164b19285e26302e7e832ad513f8e140db48afd96415aaec4f14dab2e70d8becd3fc4ffbb7e8ed0732d5c8dcf356d45646e7ce71b8785cb4975c804f9cee419b91534dfc8101b4656ba5e4d0329e9c75382cfe7e9d1460dfb3a1dd111e2eefa69b9e232d6341846ae3e15fc02635b08790743ede6b5928e1d909381d7dcd1770cbf0bf115433619bcf3f748d79a76d2024fb00b1a4a493dc428186543fba2a7a3d0822fc4d154c88631631fedb011b3afe40b9fe83aab0c62956372a1b4d4da75aca081d5f2375eec442edf90478077983e12c439fb7a2b7e39e21c139f637c1078f0e8cdb2490da2d8b50bd313a75b9033dd0b7366ef6bce2724631a207ad097b356315ce5203e88dc7cdfaa5cea259f264a41b0c90a503c2ad7a01efa2feedf084bb3b3cc8eca27d43cc321a5fa5438aa4e19c0d9d6802b551107af8156ecd93e9dc5b485e8970c6aca3c589916fac9b4387bf62efd20569f5ebec61f01d431ad58e4c39896012664eba50fb0e265ba375fe3eff98156bdd4d8c3de0982ce5a5f8d5401c7678f26e4063cde03a6acdf44e188035550188c5a50c28f52e9f8549d183e4bb4f5a22bbc0dd75aaf5382387087f7fcae7b6ada5c6d852b70b6c37727f70ba8f8b30825c3a1cebffaef7467ce2a9cc5ddfddd5d10c29895c30d138db7da2ba52cb3983a5b185a46dcc399b2d5aa32398a330979e90fb31e7f3d7c8cbb13d117cd613f6a0c2ff513064a8bc34d12187181996a073b753d61e000f597e97169b7955e6cec312bc69b4edf280e4a288e0fa0ff72bbabd72169a80089a0b18df09dbb6581ec6a66808b5afce2f91748c63ce383af5b49607d0af8b85cbd3e3882b2b742b6a1daa42e1c4c01db26e3a69e5e14b5b14229bb9ace4f812445a83e761032e1a19172b32217d959bfe2c06f8e24879e10f228f9763b5a7e42177c2f1b9b33ee17537acb61205815d5582649a9f980556fd335502c17988f5433eed98189496a8dbe5dc7103a31468f1af427fda46bdd54ac552aa5da723d41ad5e9f99eac326723ab7102182aa9fc431d76e5ad44945582d19a674be2036578752bf97de3ca85c14b35fe0fd1c9e60ead9423d859ec0c8f1018b792f62c1fe9b5418ec0c6374bf30e5e7046660e7170e1c0f851e9fc425d4a9de6d156d3224fe2db14427c5daeaf95bf8f485dca674c6cc1f528cd7472eb9d26f2940a1ab479bfa7d9dda4115f0b653e53e9020e536c9398fec17231d9672f108aa38f47631d7ba8e2222154a7d0b1c0244d935b9cbd19c469c7e38abaf311db3de3c2c496039089327577c2aac2be194b0e90b20fc7c39bccc240011c4096678898e68e0c35eb60f96631fc4f9a4a5ba270be978cb23ad253c4c61fb65cd236a53f69b9a6e74d04ad6d569a66c36d0f4f85099fb96423a723190642a4ff38551b347e1493ee7618d04b0a43f011b40d37b6ac406a9d664e160b57a9bbff53ba78fe3047a1cdc1c454db4621b3f329fbc7d2c569d42022e7c0c07d241ef0dd47f0d6030c14b22b1f64cc246066238d1430578df44e07daec60476630e4807900669a931edd8615d2a4f0aa319f7a471e36cd9e62510af7c636f37e956bfcbfefe5b970d7127d6a3e5d0e3f5455c3e88c49ecefcd39db89affe03d45a6f0bd53382e80e62e1b73474b05845f6cc746f26975e651cd20a0a044f3c1c84510be939d5fd75eb7d69f77b1909fe13f69989d1c9d8dc368feb0c96f7c661adca6281257b1b11b3b357be221eac0273e6db2fa4cdcc03c7df25a5de8826d8a51165f5922ffc5aec797d8bfbf9e697ac38e1260e2c301c803d2cb14453f63a9f9d1954acf09771a7d20a3b69f335591cf09c36c640758085811750b63cf6665ce5c4b5b8b6f6a7a4d66128b6071b6747f9f63858c127a1f3f4ab5d808998e12dabc1d524ec841a27a50e8edec839ba752c0ebb82bc360e81f6aaf6f0f8ee8dd1d70437a3771c5a2dd44074dc18bf44cb809eca421f4ef44f1a7e137772f328d7bb59692b787a30f7bbf934c4c30682cde651283bee33660dcd08d4ffe50e8ac24182afc2f8c9ce5f6bf7c3c8270d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"02a464f6fadf5e5707b8ab9d7a74e387"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
