
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <link rel="icon" href="melete-logo.png" type="image/png">
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #997f5b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">

                    <img src="melete-logo.png" alt="Melete" style="display:block; margin:0 auto 30px; max-width:150px;">

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Melete Energy</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29fd1cde83d81f754ea8db24992f4fbabe5e4677f0f52394e25f3481a06a47d7b1929a5e44b577c4d45affd640369030b8b0f6c24129aadd14fb4775ac1187bfac68444c9a1a6b3acd92cc55fe178fd0b402c02abf3b9d0cde66258513c1f6d823391d3ad3436af02134dcc8a26fa9a5836659c32c4d46b7bce6746fc572fd53e0fd08ea2c2d61f4c43954896b4e395b9e8ae3e8d82f7a424bcee5cbee7b68d72531cb318e6e5b50b5596cbf19ef684d67131ad0dab55ceebd0416bb35c893c57745a92c3214bec593fea25faa5a177190c7c12a62382d8ed9623d8dc712179f0d924188d43cc4afee80828f0ff0c12022aa488a0d1445d5b74f428f07b95b5244baa1c8df03f07f80d5f04ac47caa9a1d6399491ddb836db6d63ce5a70ec1a303e0d583696029096d3cb9bdafba3747c5ce28e5325cfd3856e32bdf638773d1f27560f441f8f0ebc4178117b6c7f2cc18ccdff8de8a2dc81bd39dbc29bbe12495a7695001511c8cbce514d9e729cde72ac9b59a7e118380d48dc2f681f0aa90438b776808fa369d1378e8e5dc606c81c37de11faeeef33d82395629025aeb6b77eff51a776a76a9d0e55f502597380eda109f7b18bb05fe5379e0f2775c32f917c7f31ff21e85d4bc77f1a3027526b9ab0233e129fb14b51d071e141bdfaf065320176d20b54e0ecb94e5fe88bbb340b2660225c428689a22e1d713557cb9f2815dc36687a1d12d94077b5e7b9348a2188844ea3800d9983240310e8f04b77084c63a624afe101d1f273e4563b43fb5b30de1d49c7d662198d2d282f57da08007fc1217b80257b26cae0d855d0311be68c4c6a186208b257e4b5128e436fbea90cbd2857136d5a18328272d373c3a35b1e5b1eaba00df193de347f5f0f789729f0021f47afa75454ca583c036228b72cfaf47c94118e296d0825b8a41d4038832f98debbb7744769af55e202290783023057c341d2c6eae64a651389db238388447c5501c90d9e101a2c5ab775f4d065cc8ed2670a83d7e0a5221815c4b300eb58df09463cabb04dd3609389f4582998024e0c91abecb3d76130092557bec3524a195e2415ac2292071e75cdac82a0295ab26aad933c5429807685d54ddfe8595585a55687e2c1557427231abadeeb9f857045cacd8da6345fe7d67b487519e067add5a7971f3a48e63b90b777a452c760a7a2e83d2801266ee66e1335d521f99c73062e4c8b066f9ae1aabdd3ee85ffd4cd255810146d14f3eb7af210e8ab9a4c4103f36e8918de212edc26b5770f4fad7b9867e110146aff497e29d7fef6aa268de8bf055957014d63f9a8abb6c3a932299de0bc56ceaadd2028f6e1d3d92eba6460e94561ac5eb06defb8a3fabb2f73b42676140463ddca3adb806018b2cf9c7c87cfaf4ba1b39a11192d0ea6bdd6ea99fcde3a8ef54bef525989ff6f40b14663bffa4d596b5aa7a053c1e37c77459e3575b5020655a23b239e5db7f99c7e2cf45500c7bd203fa571e2bdd7cc459f0c39360c0164fa5fd86b07cac1e84e6e1aa25c2df1404aa0e40c4be11046b84be5f3f32f0cba44bf2018f674fa88aa9c694d029ed198e1891d8d09a91db811e5a732764d25d3f0760d4dfc1bb95d4ffa1c9f2b15ffaa709b4c04800c62537e793b027c3b0fed1d474be9627727e3e999c81340774b20e403e1d4095e591cce8d09367d8dcdd15a3b3d319533cbe2d02d700a42a9707e9d8d535cbbba2228a0de08c395a69018f1313347b0b0c7dce64af6694a820df7ead25e2d02779b71acefc27fe8aba31075d75d7c9e2c8df1b641ae87eda0130cb5787f9c5bb852af85602cb677228966c047ed3e984860329db733e4a05ddeb1c3e17ae434e0f9e547eaf799eedef7d050c8401cfbb4d6974b68c0a3b32749b65950f314803084caa58afa1ac799dd2c6fe8c98cbb10cace809c5a49ebce7a396a4cdf9a82b61f1c91e9aa3a31c4ad1ce02942e343dfc896d1765c3ea61aee1232737a616fa2fffadef18590ef110dfa139903108d335b74795cb39a3ea5e23d46cb482a8372891b807136f855b33ed213959567bb0cf83d878a59650f35d4d5e2bfa8208fee96eee3d08cae34e763190d4d9ffd13229d649c4ee333237fa3cb114683895ba95362eb8a5acca2d5de745f82e924ad4bdf40d3b245fabf2392f280a45fc38937fce1d640a51d03009b39ad075ac2d5e4f0e5fdf9c21ec016a8411fc44dc7a9df3eb1c1716f1b660db608e44b2da0be423bbdc82ef0c963576df74a6e7279132082e10707333eb75dcb86a53a6b7ea4b63ec57daeb1032b6b66c703d0bfdac1d3d476de76e81067400dcf81eab02d7953bf627d34cfe3d60c13e68c49f77ff7d502e3f61665db668cd65a45863808dd71144ef4684fc46add8ee0126edbcafa44ff95e351387238f71cb9d8f0aa480f78169ff0e43c79bdc96c8ce38c615b7b0f0c6d18800fa77da1c35adb1142fa3e7a0aaaa92cf9d4eb3c48f1eeb9e493d59df592cfa592fa0cc5ecd3b6739f9ea1789e62e2990a5dc7820db77edb2e33905146db1bbb159b1c8da047ccb3021330175af56def16d3a017d031998c4b8e6b7f0f222a83f3a0014912ac0f2a9311c7c630372b35ed69befea41f68b9a31bca1a45660cbf9f7d5ccec3e8a893caf6825395ff11f676c8a77e2a69f278f8db98af17f76a75db09db8924e64f770b89072ec447ec3ee7294390af092785520e7084f8bb9bfd5d066165932ba5b84b3ec4acaba5e0ca37fca019d58666d6fd299cc83b9c28e4a4d32d60e987967460e61d038e80a1e1109e8097c202321686e37e76a943c0d49f979c1331b44c68089df4dfb06399e16ee974bbc8427b149715578354381c17eb18ea2a8d8cede89a16e3640a28971d22d4f40a26c0ba02ebd004941d9df611a41fb4066536dba252125c5ab2abfb210d2972dad786cfd0a130496111746af9ada75f4e44150e210ce960640dd8bd3ed3096e024f046dad3077b35b62a077268060ca6fff9ecc3ab65fb2387129862b697b781d6f4c1f1c34675ea53ebebf86a7d10880ab5ae0fa3d15afbf87cddb2f826442e2fd7a9f9e76e55c0f3f85aef42ef79b27f26601ad4cea67bd5dff422efc738650bf5937c4b87925a50eb9342165bea6152f3f06624810c851e1e37aa0492690f6f5c96578416099610a2981c9048887ebbbbbb01e670d9251af01a1c2686491e61994ec4ef6583002d21b3c051c742b68edcc2da1f171bfbacc5b032187964e9e5d945c8b40f6715bda9c6d64ecd5a8ac965043ba364723b553971d0fe8991f5f27d7942e15b567470af67533b6caec0eb587b85f21ee3916ff4346f8754a82aa831f203e538a59b5a50a4424c2701c08ececdbf93bbc819b6e4e8b25760bd9b9ff5aa1de9aa1f4ed3994d8505c9b0d98da6e4d78756bc20d1b675e9d1d1754997409e25e83a45ca15442333e6b38f8e7a9e8a861881f0159fa0e7dd3cfb99cc8cb9c3db1f162d0992c67376a4ecc681bc5082c7f577344264d1c7f44a052b6a092708bf7bf779e990e3119f458962ac1b10e4f7adc9fdbb06bbabe90f354386bf195c8719f8a220f6d25f8e20083d35a54ba2f93e4ba8aa8397184339f0d94a57ba5e11cd88020aa1729a4dfdb9ec2116df6ea848154385df26219d700120c0c3d07bd566685a328a2a0fccf2bb4b98802f8e19c64a83e53a098bb09b4f567d20d914319112cb74b90e0007bc903e5e8fa2726aa5fda5b399132a831820a1bb5ad0bd824653c09d549de2b6417ae41cb7447784f5939d8d2c63a5f452c8fa2379c992a2edd4c2863bef585d3facf27f915597307d911bc83d2ba3aca57b99f7600739c730fab534f7850ffd9b580286a18468fdd007e86cf44f440b1ef1762c5f72158ab85ffa8fd7c2fb4207c765a1cc2290e70b340e53c92cbbd0fc0a299ed3e29694c8ccfa1fbc05f4535a2d059d395e2d201ff456704335f6138371d9e9602af9e88945f0c87401e423efbe3ddbd413fa082c17440757650baceb9bae18825817eadc647c98f65a1699378f84c85f3201ad49adbc98f224298f8e99de9be4e330dcf473ae6f6e3b6c233ec25ac3de0b84adbf8cd899c336d3abfc6bc357d3b74548aadb1c8c97618ad750195ad91295108b8e02603b2ee7b46db41c4469109b2925f7b33a3c4f09fba44d8d3c3178204c04f49d762aaa3cdfb6c753b69f55d01608092072d31c96ab7dbe092b2ac5c02cde2148df11657f19e86706878a1615cbc6722315983ce7f613bc7db55a8782b6429a4071732728be7fadaef091791f73e08f057c0c096da000fb74a5263517ddb1c14c3a8051fc89312a92ec1536284f2de4e55c6bf7a1dcfddf3501af04c19b12bf60b76f88c81f13f405a2434a3a0c7805a0c00758f85f31cf6573a3af706373aaac642058850b8e944919e270978ac3b915d0c04c4508f03aa61a6b36b033a4694ed8815edc009eadc57a27abdb798237a0a0a00f1797e160108614eeb2eb4fa6b26d45ffa611c5cfa14bc94d1bef01f1dcbce0369bdc8d539e74987f8c877220e55b30f6bcae2823a3402b6df9d8560f755f0b75e924970790c073d4e98593c641991a5bb529040f76a21bf2e0c73cab191957f71502f3755c18c290e6cfb1fbef31877258e77407cb34ffa76ccca98154248fd567ea84217fbd89e1cbcbd17d03cac37bf7099af49419395e57831de155764d28995aa3c680603a6545684ae4e21c692d9ca86c44a400eab89dac506900a45c62715e85a3a6936a46df5bc1381a0324736f663b86df1cce6a4c1e6119ba9db920d6cbdb25036cd2b1f2f7ea4bacb7d810408653b9dbde3ab5f97bb049c77b807e66a7a20b734d0e1f22857f752655a3dda023fda6b4b885a14d13f1b55c3425cf8c8a20cd50469bc6498c8ec20f1919314069fbe769c0221acd877be95833a6dbe1bca98a210be2ec8e5a623cc37f270eb602f42e288323beb76f32e982f77a12d64a2c8523298a12cda55ffa229c67c916ace45e35dd8ec4e5641a8084c143a611e596b30640a27c2679ec3558ee06e29396d155096f7875a64e3d715a81e04687b64433312ea62110f70efb93f5a338116740b5da08ddea6b45c4142210b6b86c814d65b89fb5e9b8e5db4a29e9aed8bdf3c1d4729d706c60a7008911a9e374e9937d75920a15e7e0817262cfdf89ca086d2eb81483727f0ad1f60962fe13bbe1dae36d6a414fda1edc7e7312572d19a6d4edea55b2dbe6ee0c1fd05050b4ed21dd68df8ebc3cd6002dc4d2a49f0506a53bd5784970d5d7d0fa28d1a90dfb168838b0f79a27132b427795ecf286bed0571c221313f1c85753cbd22b480cb4874bc21e9d5d2040880937890b4cdd604eb32020496d650820747f30768bf8f57a401858a48bdf109d691d5c075da85b8335506d5da7240e781e30e352f68737af8b3d1697cf843f745b89ab2831b242c1ec8ccb0fd93d8bd0b013a054d3a6b6bce4e41a3610408f4f547f05ec3cf083c61a45b387fd254dd8ca503269f574cdf85552dc745755ad45955de338b30f17bdd9cba128393b09b1f25fdd808496cd5cbeaa8ba8c9906c65824be5b489dfaa4b0cb1b139a7bcf21ad4d1a045e43463677b40b383ebfe6f0d354bbd3933bc24eb7d90dc6be8b1e4cbb031198d38b9fd45aeac21cc83430ea205eeaeaeaf075591e4428985a9bd8515a274f1d7d298036156dfb3f515fe54793fb90b9621cd259f4b1d58cb461fd8422f5d183a3a2d0ee9e76e2d108919e35a7dd301787bc926aabb5f6d026f5cab0e0443881ba1a6c78ac7a4df88c1f5e3631b63e3c623a26dede7ed92250ef7953eb3094979aed284b9c09688993f8a477f4cdee5fea07ac1023007b4e9f3634ab24084774e7282965f71d37cb0e53a1ea439572c11476a72daa1e7856dce8ed038411070d42083b4ba6b81d56e796a71ff6d2470390caecb645f779dc6a72aec542ef0c6a59aaf6ec0b475315d635076f1ac6958070d0c3d0811deac9ce6bb3cfdd3fa5d6ce4fae52a05e4d20c0bd0ae38e2ecc9cbfc6d9518968a886fee799232149e41c712843340b73db208cd225843657f878e785c95316ab5e44dac11cde97d3729b8bc95366d40b0160ad77d2d58247d23575252a28e1a826cffaf5b81fda37d26cdfc12ab6b1be26c7e5d56d7be82f54602e63e652a59f5b5cdd2523e0b16409295349ca853aef81bc12ea7752ba1858658c63bd4d5bd925d944969e8114512918aafb705985bc52e9765b54533b1b09ff4fc5c9eb296e3bf3090d633194e690d651c5d1a657cb0e1964b54bcab7f194e637bbc89778e600a69e9c664e15c5a06bd36fa236b5100014a28cabd221cfadb6e6670170a5799b0c47cf8120f60d27f2528791a59b808db477a1e0c0ceda6ec394f54eadfc28fee49e2e2cbbda60e8901caaaa13a35ec7728b9b3d4163c9e02ab95470746f7a0ce62174dec73cda9fe83f2c9992af4bb44b9f6d13a2490bda42ec92225a7c42229b6dc0ca400e494de66de11235c047da1073fa7363e0f6204c6816292ac558f1e56f2df8f5b5f335be8bbdb33795c1bdd1505d23a887b5793cb70440505e19790c330bfdcab16ca36369d46cbb09a9b9b038cf3a2b33eb959f0b2764cd2aa3b27dc2f89888daa9753f9a053c98b701cd1be16324bbccbde3be13a1ce4c69c367bf6733ec020ca4407f43df614fc50038ec72f9adb2d55b373c3c25d714b299fcf28834df44c78344469908c22660cf2b479dd56f88dbf7420de0675e90cbb023c5011bf6059c5b417f1c89dff4fe0be30b4a45b0fe8bde7a5f65f21ebb27fe800087d5246b301154a507e4aae76c0e7d44bcae8894de900c2939c25939adaac7bed1157de353c24548463d89ad644d735ff86e25bab6792285398ef84e757297554e0861992bb11424bf200413e5758c0bed5f62fd4072f5c76f6f9150d6c860625a08ec740823cc7cf104fd3866bc141d01aeaaabd378467048f36d3a739909d5cb747230c8d9dbaa02abaeb77c11f188ff34f4eaede111d2b9592aebe95fa4c824434241deb28a2f9fa4470b73f1e506d8cb09dfc9e3cb40a7c7e245888fa567fb39b3decf67156119d61859be5fa23a35752e525e430830ed82ca15ef3d478856a3cdf8d00d43d76221de8970e8c4b13fb59e44cab4bbabe68bc45305a9bfa75616bd63971d0c242e61173449409cfe050700696a5f0121d6e4d2e2119441059598f4d3f7b8c60444a0eab5d40d7bba43acb8d3da9ef379c6b74590c75c53f775aab469ee1bc0b85abc0c8b924f00dccea49cbd638a3a802e71b2c76f59fdd649d49d6b1a6f6e5cdaa245db6deab35269cf04407eccd953460a7d6b091264c713d56cbe30a0de6d9d12c91e1fa1603484d050463b8f585303746fb58b2da2a4edb63108a84ef5fa03daca9000f8367ecb189b2306eb691456faf3221e50d1977ec1511ed7426a3a89cce815858355fe907771bcd58dddde36994f8d9511d2684527d8901e9b8cb539f0a6bf645f40c5136f283061f5f5fb55dba0033beeca566681ce35acfcf80874177eeeee1c32c711cbe9e1c2497e9b4392175c9672a005ba9f9aca3f6c828e5e26dbd42933d65254c9be93196c03929d3c4795600bce41d2d7d1b63a59972e81299334811479c24b8f4337b9aa16a3372250139a3c645a6cc44ef19f7b1df450b1658ef1c72ae260915d6b245703603af69f4a5e10325ffc016d74a16ed1eef392e39944a3258d91f8abd1100464a31ca82eae13b9b094bd37e738143775fbb632062c005502e847cdc497ba0dbfaca935683305f03d5ff8a2586702d29e65aa75a696108839e154f1365ecfac8512fbb5feb94c4fc75f5e6bb4e3061ca3eaff588c5fa35d679e799339691c4bf2e690cf163e8d282e738dddb1819b773fa46c9e3e9656f0f1e0dfb45b071d55913ef2a6610bfddc8e4b0c77ed99223a57aee8574c5e7e5154c176d3f0fd20e5bb4c0e964ff70d969029dc2b53cdae32da2c0a5fad04a116f0fe152e2283eab62a3e82d40a98027f87ffc7dff47970c688c555adfff0f0ee7766c46a1feaf6f3d2166ba00c2cf7719ddc8dcdca408876b523d18975f842660883779b07dfd486c15639d8f461c56e0b3a247a50c06727213027aa3fd05b4c5217465f6aba0e6699763f595f9a9ff911623760fac44d994011a2757d9a8240239eb3854a0a926065c4fb7013bd80c6a1af03ee56e60b4f8dfb0347db0f7d361e2fe2efadfa6c168720e7a96e9e284c57ba7af01f871d01b1a74991ec3bcca5309bbfe503278312c59b1816df6886be09c8f85272e0b040b85c7e48e75bb1c5ae3a348dea4d7c40522b88beba0c7457077df6a0f7eb2c7084f53cffab950a5d686257d0d3ff2cd2ff9575c84b5289b9b94458f912843da50de4c9ef0242a5d02d523ed713263074c006f656f84184cc12a2336d34a800563ae99134db77a944357e98f9158c2b0ec3ae68d3424ae4bad0d4ded0b60bf09321430c4eca4e0d62db681009b536a1beb82aabf20b8cba8127cba4f9c63c1e8b076862bc6ad1a8bf5ba27de352a19466157bd5f17af59413c4b68d10fa7231bebb80a1415abc8dee8e890aaba7fcfc4d610db3fea7c0b2cab4bd0eaa714bff5288fd71ae3c5e21a1886c81ed7e3f7e0a32159fe9aabfb47af2a077142c47d920b13df98f6d1c6aa1e95bc1dcd0acb2ecdf5e26fed26041010f89c64777cfcb8183154ab0cf7df397a69105a892ba8b0f32675c9da3a5e6d5338830279bb57313c807860cc5ca021d42154fdb92549c988b0ef3a64692889f7cb62ba1453b229fb18a4f9268b83977a935a356804e9c6725d577e5c4ded4860bd4845848fc01f79d391db05f8e45b2b2ffba8dfe16773967d30ecf46873f33ac89822d24623b7370c1b006973fe08caf3092d0d9b0788ad464a127912155bc6ce17879eb760073a15e266137d894cfda8aeda4b56fa58c74265c55d8d6b019c5d9d59a2d619e9eb69121d7e6b594f8e53ab4503a4bd1a52ee8737908d6271d8cae6cdce90fe769cbd2354d44988a40ad3913664545a96d088f036d6c1ed9c1635880ec5f06ddee926bc7537f9f1f24a50cba29ccfc74f2ff0306acc351678dc709afa383fde30e6b90e24f4094d3001570591197e5a892b1cdc4f94506c797c4e16ae311e9d5c5a8099c37fa053fe7c778201cd551b276ef46695a1b2632c8368eb8b81bfcb6c41f40265427b4b5614f6383967fcbb14c03af124123314989c885b5e8b1473228e3131808580a50ea0e0d0edb5cefa8c5ba3889309f02d0fa98aecc3569ed276dbad2d7d921f6edd2ddf553e804dc8a37e6a774b53658dc846cc274813e76d321bab836f6dcf72a1278f091ff0aed02f954bf8915a9458ccd274585774cea3420b495ec9598f300aa0305613f138a0e3f46b41a574ea2495819fd8adc279d78899ca470cd9bba08927bb713b5ac55b6cd2995c2dbc85b3c779f32885ed1d8ddb4bbefdc3a97219975d1f517eecacb35e8f0f98de2df6509ee90e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"58d0732f9f5b530239ff6f003a3802c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
