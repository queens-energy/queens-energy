
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #72431a;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #72431a;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #997f5b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8313dc2bd927893102c2029d02e414750284dfb9adcc277c52df6f5a0c94f654f8408f48ab820903b5376480993734a41a98b979139d9fdd461a27d5ea85c5ca38239c0edcf335e9fa51511781a70f0caf02c7ea736f86d3475af961a6f5a8109b8ff58b67f2a564f9fd00052085d29d1d622d8f8e6f5a8d9f11eca1bde3b2ea3501e89d1b3e464cc353eecea0b2186c3e88f1da1f06774eb9c9455eaa7c95abf061b228b221baaa6f78dfcdd82aa61cfa2066a304500457e5dfbd56fb1e944ea1b879e02b884d6eb25886ae38d0a8f508c2f7a31efa259fdb15bb930973e312f37b8f50fe26e9034e1e2270f207e9da608d86ac182a47e9236762dc047fd7b79ac687c69d6c74124d448600c2da1d776b001b5a891b4b1f6afdebc3eda1563fe8cad19fb41e767b0b0df4e6b87740d2c0fb8e85be89c4d42a792657094c663c16c4a9f081d4383df1a01964a8f14ca4189e6083d0e7d02ab246d53e4ad2bfa54e7a77f6b69b89219f8e2fa4694dca7e371c2c6b9f658a2f036d1fc99893d64368d3c05ddaad086ac1a768669e604c3d7fcda4008a2a3f5554ad42fc004185c2746a4670e026f19247c64478f60864f24ab2a9cbba5176d93b34579846b9682bdb6593ae0c585491ff4e48b2b0944744677711be1c9770ef7d2a5cea7cb1fbc205387b6a521262bab7f3748b283d423e325e464d6c2092e57330f940783d7552f630948b929afd090e1182e30ee3efc271f49745699ee36b89c870be036d19aa07d45d44176a7ce711b3d5819f34eeeca1b4acca7cd239cd4297ef8f675ebd37d5e9c3999dd0cfad93e9c71a317aa76dd009231c6b4972be54f7f80ea8cedceab28155851e9fad45cd3f8c63544b98e7383bb1aec212ebdd79b37256b9b573ea946e541d747ec3d9083e8e9dd6c49f94d218a15dbe5c4554fa1c98cd934b469c7c7a440bb04a751279c879c422891ab26788c79c678626146116d7136be7d8d4fab5cf81dc29e21d9e67bfe2ec17a6a4028e03f39ffed5190309153dab39604e40d3b970ecb9fba966f244a5c4c32e3dfd5534cadefa1a72f48fab31f3975ee387385852ca1d8ad85e9e9a16b239fd4fd441d87555a5ef2dd41eeb6609fedfc97cde65f44ebb4466b9c25a066e333553f61b60a8d43e69f762cbddf0fade374de8e5268309ad61320c8206d62517b523ef6e1a9756c065d316c32cdb9de419c52c003aef7d1c573be61b671dc7837e6a9bf1295d1b0f98f75df82383657a9c2da386adf1f868a48ea39470fd11d2ea3130f93cf934a24e4dd89c14c4d2a3ee50671cf472abe43bfa5b7c68e6f1fe230cbb88d6809ef4bf63dd600443443f7f1f9904c666e502e965ef669fb9d0e464852dec8948ae73177cafa0833f0d5c465be125d7d7d6ed61a6f52f6132f893f5853c78b6e0f481df70029d86ce73f048920d790af30e38efb2aff26ab48231ef88b870ae24abcb97bfbb0679f8ebb3a5f0e1482b6a3897d08c8c0e9c179167d77db388ae0e340c488c9a56d585ab8b83f770520572e966f1249bd3c842fac28ddf2b58ab694cd552292134fd58969bc115dea60c0f95b6a9e203ed3e30c8ec48f7d5ce8b9e5e8c6c2920aec815b811742c0221a013871d2aaf35f2a587a13eaaaa5464170b76608a967ef333058c809011aab8b5fca834d89c7c7571d2cd8d397c774126ef3de779a988aabf9c8d2c455e10555d9d9dc59f28c3f1d9d1d756d9605c02d9e64903980404ad5aec090180ff60fbc2e716778164e7315459ba3dfcbd7ffca7d9bd0679abbd0947e07d75b6268e3b6a2e60dff052e5e0952097f5e3d6906f74db268175113ff8f4dbad30270f6590d43fb8858aaf53b398cc354f11322f6a87679e263793a2e9c112ceff8e4f8f61fa54b907fdb58bb2a13354016b644483bd4dd1132e38e28c00406340b0c8544d8f227bd7c9e924d3c04a5a3249451d8a2892f09c16b9604abb5452fa7152506faf244fee5832635e86287ce2e836b192c757b559358f91b2d985a3f83554e93051dd3784d94f211cc7d662d7c63b79ac231741e1dabd00917e2edfbf3e41c1e066c199daec5bd09086ddff9a8f172c87701996ce4c0b31af4cafc286e740fa7d030f34d72c223c33d7b03d6121447df1894d32e5aa791b62aaecef9c7c011e158c04b28c18c27af5defb9feca5cadfa062c40fbfd6d0bf422958f859fcff53e18d202b08a252d8f08385bfbf949bebdc735c96424f26d2c3405963a1ccc731197077eb3a045627c6536d19188871e71815a54d4fb8e665861af1570ac81cbde51940fcfbf8132c9ef8de5e5edffc7b01a4e2e7334838d7d9a683e872508c2e42f42dec689c92456d785e2b0d73c08f30f0e6c87f1e90059490fc56886422db67d149ffec186c812884908a58b26de7f592a93aeacf494f3c17d05d16ae86a9cd3e66dcd65f96537a58073b28542fe45a9df2317019391a0ccf47aa14b8796a025970149f09c8f7c24427d925321ec6e71f3e420fa0b983b56598643cbae7fbdd0ced9f68e29582b86629e22cfdd9faa12d0818f8bf9de175277455f4242aa700c0fcd01ea45b0e6277c7c504deec2c8fa8fd9215ee4915ae8ad74eb3681073dfe2999e4061ed10d4ce9c94cd22883d20ffe0bbbeb99933022b89ecfb0e5db4aeed0df003077850fee39958eda3ca16874567aef69655cef6b4a5066e76289cc37522f2dc26612eb344b10e04ac69295d7b4556fbffa99a450d1ce3c088a92c70898a5ed84e1f96af2244d59c9d28a9b7546bbe6f63568b417b8170a9bee05e1015a3a72216ae5231925f03df897414b98328d3531e21830975cca17ceb7723d1c6d78b494e67f3da24fb8cc1f42a33bd7ed45c6d570ed9bc7655b0e878aa68f03573399f20693ff9da2b39b2f6bdabc2d3c2662da4ac0d43d6548f89b19b335a717d36649e96edd1f649977e4b53df731b822dbf7728906e510103707c8f87aa98419a08be6c212adb65cd98edd870eb530c1ce812fe3e78a06b625e074b4849d3e7957851cca0d29e106fe167d232ca0633a439767e4cb963865fee635a31cbc896af5305edda2d4b330d97a386d4ab3ff3783a9e4fd63d15fbeec117e192e3a65f7c0049dfac7303a54157bbce9e9e2be721ad19582adef976c6ac1334615c69ee3020d9c7bb5074c86284841c3333e2fd91c87b34d69d5a59986f4a5f6e6c4c6d23657b98cc5bfd660e00796c788af61083bfd5118d21c1cf972db334fd2c35b7b4931540eabe205aa3a6fdcb5dfa4dc5636b9bf289096d93896a6c00560f770b923870ca81271ee8862fb8973f133191981fc8fc4ebd02069a64fed26d09e0dca07bc5f9ed9131b693a60cc9d875fdf1b1ea49641a474d34b4f47a36376b8b9899a40e55c14f0b57eb378dcfc2d912402248e55fd7c1a8d931b62ba4c3df836520af1a3818860c61676fde4bd1189bcbc20395ceb2906c10bbd38f031fdbdb7dd0a2d884bc85344106710104af7b528cc1f879e23ac95e825782c92406a787f9d14cb959a158a0bf61af0f8e48b0ced0123bebed38f79a0f05f28ca59778d1128bd22a3d0d299e1464705f0b7c5842e815e05f23c4e4687325bd519c0956bcf5e358bcecc6c15b32894630eacc698b31c00e50f8a7770b506037ba152aabd67b287afd46e0209e1952944baa2c2166dccfc5faddd069981582c81c49a73b37e500d2eb25368c7a9028b207c7295fb0b593ae4388668181cf2275408788fe19f433abb1ca6a477efb127d0d7cc5f99f227aa2ee2f23dd4b82a3353ce5c13d97c615ab0bb4f61b73343daedda4013d4ceb3f1af9124bb5f3a8e2c59627021a37511231592c82292a9587ed47924740b511d4cbc6dbcfacf6c2c7e047594c7cb079de14123e364b0703902570c90458b8c2439c6f4489a728aaeb51c7419646567790199d054ddbf3c6bf42a5d1c84cd73245802e54ffc1952852019c9dd18645bae2b3fb682f1a3f92c1ad8903a44bc57b61bfd2f58b06ec5d9427c549e633abdb84a11b49449591ea9dfc08b9f92cda52e027f55af28d4b6e9cf3a484e161ee71c8079fa5c7f7dcaaf5877ea513f81089435784e2a45185e7410a43c526dfdc41f47a2ae7552bebe26397da4cdc63b3d1b66af05023111ad7c5a4c0d2edfb0fb3fbfb30af50cd94009afb1029384c9e7304733cba2cb19a23f7f71bd1693b921a62fcd7b86721f9afc288b9dc838b8cd2354ca9382dccc0c542680cbb49f89fd91a20b5870ac7eaff7fddc90302915279419b7edfa9155545e3d197b5ba79d7df54cbfc4ca1a061abcfd3c58b8e2dac10733164c103b85f56ce440b0020c731d16322cc96a4ad6ad49c3ae46a2da281568041a8b86aa589ac8669bdf7094999731257f3edc2254af28fae5b839301ece78d3c447aa130ce75e055c8d7644d944e5966c0403235e1a6f0f1cf59cde4f49c4cb5ea41de131e3a16ff05a66e45804e1962e889039800cc55de6501df7fdb5d989825640038935a1598c83a4f07f6a1b3366fda9fadc0cb28a2f4edc9f123a4635018af925bbf02493ba508b427f1ac101a6514da2a4ebb0cdeb152c86667ff28892f3683bee137e2d081ce9506ef28f20ca059ee607ea61e87b75b308b3d9c7435fae1a473bae154693e680b47c725804ae8ea7917baad8eb5e6bca71ff6715cfd852bd7ddd551679791e49415e5bfc1c88a278bfee58712ba032eb5e6ac44a464484f624e3d38b24b8c32a564bdba7872c6634dc927e024e7b704695804c881a31e1067233177f068caa891ae0bd9ab5246a3f1952f6e21e07d03f562b585e27b24fb49a6cba2602b09d525e8288e67a0f04058639fc76f7b1325f976b59a0bca5c667c3ebd322abd149ad08b7d3e630705b4b2dfb82552922ae5a670150db7ccfa4736a4ba98b568a054a425eed68923dfacb741b6c891e5483bbc2458026dc5640312b7ee8df19b09874e57f2e883b0cc8b9a0ab74124b9f39916bde14f6469adc3200a94362dc6902492da4d6a1eba54d5c0ebadf2eb62e013ed833a2d4fa41124a5fa2553ad6537cd5e08883414950052b9f33e7676212b728f464af24d64aae29b3d88326369910ef3401a61a277a4b3d54a3e164afa428e3058b69cf46926fa42088d37655371343e82855b6b02ce284a2a1e08a7763e9a23b323be67d77733dfb7c8f883aa1a47b2df21083faa9a3360c32d2ef66f39e830a81651cf4f70bd5842c527a4c2d6e6b4f8b616c648eab8f2240a0c0ec1aa94e165c8e5e6822b88c900b25fcb02eb716a47416144f2c3807667c86aad6341fc67f4d3c3d16fdb3760db657b03e7331253f8a843f6843fbe8973f31c0f027aa179cd4a57e15ef4e64338a5db5af1e6720e430a7e66d1b0fbe87b955963e18d1be25787243c70911cf3ef60bfd0af280b090161fe52be1450519d4ee16c214932288b33179e5eae9cca8c1bdf0a0f5bdc392760cbc39cacb74f4fc1aab9c362b51c076814ad5806237710488c20f186fc89c18995375a9fb35d01c5756a494b4fc88d2587a9e54032b7a6b26736f82ef42f64af10e7bddde840705a578ea9fba6d9d026431289179a3a584628269fd13ddb4b9f01c716e3d9d3db4ba060bc09269ebcbb23563f1ac7926e93ca214817da059699485a0928fc8dbb17687c54064a208cf1ec30e62ec19664f71218e290f5a1125465d639041649207e288b5f89a8b401ca01119e2d2330e0101c9147758086289e09d0f372110c75990ba87c953e8886aa4afb4fb2db52770a218ea357c09f294d65ca72628fe4ef2c16e4d3b5f176a84caa88fd610d6ca7105842555f5b64f1c4c8fdecfca1bf236a3415b0ae635836dbc9705c05421c8b87a45b7f45da28c39a46d0b7d0f3c9622331468fde3be6345d14e7f009c3f76891e3879974d96d740fa12d2dcc6c86251876fb3ff20024eb48f762197d12f4c6ac53c5ad6943bae8e5412dc88d65b1c2f09066d844e2c8d3ebf6086bcb5fa40a73f8d39f814e54bcd1090ae3d82d4b98aa458bc62af7601fb5bb7cc0161026e20cb963d3ded58c6f78e2504a369e11d941186c7b172e27a013eb14266a98dba57f9d974d9d396f7f553c2e086dfd787728a7edb89375e3663545de945e1eb32a37f2e73f5a73f9a2484260a458f0eed8914fa468cd16b371aa07b1b04373491f675c4622d0ae0e79f16eee7ceeb56543894109371f15f4de414fa24c74d0ac9a4fb2e6c9e799eeef9ab7d67745160da8e4ebe301f0e8585e132c657729a347cd9dd924c6e4486375bfb3b7915bb16b4177da296d03c3bd602bff987edad99c1f93c785f6f5f4d6ec96ac06af06b1bb84e8a14c330ab1bb6aa730ba57e8c2db977bbeb4e9210b0a67b876ed64260c88b952780340adef62904ed65f0bde980dc07807c43e4067dcb6b1546a2610a2aef0ea1c6313da9a0c0a4c0af1ae1d809063048ecebbcc39c9e574dd4a3651c64f84d279e256132bc80c39c99a916957c02e045dd52d26f2d02ef5745357f5b70a66a258335135571d788414ddba7968cb33918a971b1bf19e8af92dd5ffb90937640d9817c67efbaa0215a09b70787be2f8ba84b51d054d73ec7de697f2dfea23d671ff44fe07a42642d9f6a853942155926e2fe6ef49a8de7a5ecb1d1f4d2dd7233397348180855b52f71840359e5ff27d1afde3b04c56496cd588cff3f6ed7b334aba06bc711f6a1fe3f92bcb11bc6529bfd48ad958397dfbd0b4801577822cdcf2d763a11e61ff49e10298adbc72a28ad3472ea582ade58c04518ff3ff560680c4c434807d354a65ee600075ffb8a08a9d35f66db1ae4e09b8553a47042dfa3a4caa4fea6b57f033ea051df6f491c0f90c66759e13d881d2018ed27b7d5a63e94e120fa818ffdcf46568c9951ef6cb6454f921cb52ed8355da5279eaf5036eb9a1114d8d8ec2838689b59f7245bdd62ff2bb8508750c2c45a0fa54df6402c47dc0987dd96d15373ac4a70f8cccecd8a0728af4ac9cec8dc608ddb321fcaee42e430f5c0d66e90e6e9d68254a8084f0cd8109c2af08d1611d8b52ef9b802fea8ba338bee7af58645f1ff98eca8033862486e704fa10074c4dbaa99ca6e813d22bf98b34a12ce06143c7c901233e44964dc50afc646b597edf5ecd33cc0526861dc01d747ca991973c7656aa5d799785a4f669eb7b80fbc974077f1683a47ccad84c157c3e6107560ac7f89818a6d2dccacc040cd04fe2e99ae07eb9b5596813ef8b5103432170285afa942c0e86254091c5b6b5512e31106c57c232942a994dac90777209f35ed1aca5c484ca5c77513236913039b2710c8022061a352cfc61f390f794db47464cb2126ebe6b1cc47cdcf4940833b7e0ac36322de4df1d00aa2b741a3d1a9ba4130c9caf330452710144618ce21a4064b4f9fdf453dc64a7daf57aebc98fedafc11094a8f8e3925f8d7428144bd27f89864c600b3a63bb4d6003b97ec57b2910e45eefe42ccc9960360ab7f1ba5a6e56497166fdd608afde3fa4f2f48d10488de68033ef13aaf763ae5ed49cad939cd62106ea986f2d5ccbddec10afe99119cd5af73ef4c239b4ff3fc08258cda0927252f41c8a700832cf9a0e93cdc40404ac64615d5c2e04efad5d206d4c045d8cdf21778371e33818218e1cffe9447a46a339a3ce6a9bd802ca987ed9b5cdae6f6f2e96915e2b17efaf2f1a25dc242a5e14cb161155a560825be2c3ad16f8bbd39a1344c8df564e03dd017f0488d1c13cfc7ea58ad53e83e02f9a869ac47e6bc2b54d6075eba672fc2350c0981689e2727b5af510ddda7127d2b2d6f656a75630c3adba6f61fd8564491010b88805a7e753e428ef0219652a7d3ab71c036b36e3cb05b7c0ce343538c21bb53ad7857eef53f4db5d3791df67e8f5973e98005603b72c8ca88e1a66d45911bb8f1d1bf1791f8e5bb4d70c20fc24bad6e773f62bebae72fc66cbb03da0def38ff9755f7ddee84f21ba2d4c6ab85b514f39a2f34d9cfe2e2c871f15076e067ff9581ae57b9327cf6542cac6d5bafb4033e0b8ecd1c4b814c8ace885ce6b846ffe39a7c925dee06b4a282a5171669d8103b9d93942dbe8cb8ff45b4a6e50980c942154a71a194e99eb28f95aa5bc391e79739dc805f111b71a622cda55347c9db50398f2e159ef88649b16f43a0c91831b170a7d47e764bfc307ddad7f7b139498ebb521302673db29c9e18a0c0edaf4849aeb68f6f4e9e8dfed79cde9b8c9e4294cbddf2b28f0c31cc9480ec569f89a9d53d044faf98baef5bac527e01ada105505e9c0715ee757ef35c8d8a5df8d7974e95d420933fd141e82171396fba5a3bfd9157ac0908e6917457b59bbea6f8b6095856984676d0f735dd3b5772c7f13bc413efabf82429cece9e482181aff6de093eaa3c6595ce0bd8d4a0a5c0a0120523bad0b145ff6c73a96f122b9dd27106e19aa9fb923dcd19455f422700bb0e77b762964334062a424a2fa26757998ea3c6a2d23c5de6cab8b09c2c33c39db1a96facae26ee6d871dabd267e4991800baa403f2fb22add0e898a63eb516a3a3b0e2442286f847a1074d313b7b95e0f6a1e4d83a440087557d329d43ba74724ed60318a2991a668cbd4768ec547f3276c23ee8a4c1734519b30e991f26168e713c5af5ce3f8a576b3e32f4fd9b7dd4000673f6f90c6978","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"fb6d30386e26c2310c18d4057a9a0851"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
